[{"Library":"abp","Description":"Honeywell Basic Amplified Board mount Pressure(ABP) Sensor Library","Sensor Class":{"ABP":{"Name":"Honeywell ABP Pressure and Temperature Sensors","Description":"This is the UPM Module for the ABP Honeywell Pressure and Temp sensor. This sensor uses an onboard ASIC to output values of pressure that are updated at approximately 2 KHz. It is capable of detecting pressure in the 0-5 psi range and it has an i2c based interface. Temperature calculation using this driver is possible but not all ABP sensors support that functionality.","Aliases":["abp"],"Categories":["pressure","temperature"],"Connections":["i2c"],"Project Type":["medical","industrial","commercial"],"Manufacturers":["honeywell"],"Examples":{"Python":["abp.py"],"Node.js":["abp.js"],"C++":["abp.cxx"],"C":["abp.c"]},"Specifications":{"Vsupply":{"unit":"Vdc","min":-0.3,"max":6},"Supply Current Digital":{"3.3 Vdc":{"unit":"mA","min":"0.0","max":"3.9"},"5.0 Vdc":{"unit":"mA","min":"0.0","max":"4.6"},"Sleep Mode":{"unit":"uA","min":"0.0","max":"10"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start up Time Digital":{"unit":"ms","time":3},"Response Time Digital":{"unit":"ms","time":0.46},"Compensated Temperature Range":{"unit":"°C","min":0,"max":50},"Pressure Range":{"Differential":[{"unit":"mbar","min":60,"max":4000},{"unit":"kPa","min":6,"max":400},{"unit":"psi","min":1,"max":60}],"Gage":[{"unit":"mbar","min":0,"max":10000},{"unit":"kPa","min":0,"max":1000},{"unit":"psi","min":0,"max":150}]}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://sensing.honeywell.com/sensors/amplified-board-mount-pressure-sensors/basic-abp-series"],"Datasheets":["https://sensing.honeywell.com/honeywell-sensing-basic-board-mount-pressure-abp-series-datasheet-2305128-e-en.pdf"]}}}},{"Library":"ADS1x15","Description":"TI ADC Library","Sensor Class":{"ADS1015":{"Name":"12-bit ADC with Integrated MUX, PGA, Comparator, Oscillator, and Reference","Description":"The ADS1013, ADS1014, and ADS1015 are precision analog-to-digital converters (ADCs) with 12 bits of resolution offered in an ultra-small, leadless QFN-10 package or an MSOP-10 package. The ADS1013/4/5 are designed with precision, power, and ease of implementation in mind. The ADS1013/4/5 feature an onboard reference and oscillator. Data is transferred via an I2C-compatible serial interface; four I2C slave addresses can be selected. The ADS1013/4/5 operate from a single power supply ranging from 2.0V to 5.5V. The ADS1013/4/5 can perform conversions at rates up to 3300 samples per second (SPS). An onboard PGA is available on the ADS1014 and ADS1015 that offers input ranges from the supply to as low as +/- 256mV, allowing both large and small signals to be measured with high resolution. The ADS1015 also features an input multiplexer (MUX) that provides two differential or four single-ended inputs. The ADS1013/4/5 operate either in continuous conversion mode or a single-shot mode that automatically powers down after a conversion and greatly reduces current consumption during idle periods. The ADS1013/4/5 are specified from -40 deg C to +125 deg C. Tested with Adafriut ADS1015 board.","Aliases":["ads1015"],"Categories":["electric"],"Connections":["i2c"],"Project Type":["prototyping","industrial"],"Manufacturers":["ti","adafruit","seeed","sparkfun"],"Image":"ads1015.jpg","Examples":{"Java":["Ads1015Sample.java"],"Python":["ads1015.py"],"Node.js":["ads1115.js","ads1x15.js"],"C++":["ads1x15-adc-sensor.cxx","ads1x15-ads1015.cxx","ads1x15.cxx"]},"Specifications":{"Vdd":{"unit":"v","low":2,"high":5.5},"Data Rate":{"unit":"sps","low":128,"high":3300},"I (continuous mode)":{"unit":"uA","typical":150},"I2C Addresses":{"unit":"address","low":"0x48","high":"0x4B"}},"Platforms":{"Intel Joule Module":{"Notes":["On SeeedStudio Grove Shield for Intel Joule"]},"Intel Edison Module":{"Notes":["On SparkFun Block for Intel Edison - ADC"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1083","http://wiki.seeed.cc/Grove_Shield_for_Intel_Joule/","https://www.sparkfun.com/products/13770"],"Datasheets":["http://www.ti.com/lit/ds/symlink/ads1015.pdf"],"Schematics":["https://learn.adafruit.com/adafruit-4-channel-adc-breakouts/signal-connections"]}},"ADS1115":{"Name":"16-bit ADC with Integrated MUX, PGA, Comparator, Oscillator, and Reference","Description":"The ADS1113, ADS1114, and ADS1115 are precision analog-to-digital converters (ADCs) with 16 bits of resolution offered in an ultra-small, leadless QFN-10 package or an MSOP-10 package. The ADS1113/4/5 are designed with precision, power, and ease of implementation in mind. The ADS1113/4/5 feature an onboard reference and oscillator. Data is transferred via an I2C-compatible serial interface; four I2C slave addresses can be selected. The ADS1113/4/5 operate from a single power supply ranging from 2.0V to 5.5V. The ADS1113/4/5 can perform conversions at rates up to 860 samples per second (SPS). An onboard PGA is available on the ADS1114 and ADS1115 that offers input ranges from the supply to as low as +/- 256mV, allowing both large and small signals to be measured with high resolution. The ADS1115 also features an input multiplexer (MUX) that provides two differential or four single-ended inputs. The ADS1113/4/5 operate either in continuous conversion mode or a single-shot mode that automatically powers down after a conversion and greatly reduces current consumption during idle periods. The ADS1113/4/5 are specified from -40 deg C to +125 deg C. Tested with DIYMall ADS1115 board.","Aliases":["ads1115"],"Categories":["electric"],"Connections":["i2c"],"Project Type":["prototyping","industrial"],"Manufacturers":["ti","adafruit","dfrobot"],"Image":"ads1115.jpg","Examples":{"Java":["Ads1115Sample.java"],"Python":["ads1115.py"],"Node.js":["ads1115.js","ads1x15.js"],"C++":["ads1x15-adc-sensor.cxx","ads1x15-ads1115.cxx","ads1x15.cxx"]},"Specifications":{"Vdd":{"unit":"v","low":2,"high":5.5},"Data Rate":{"unit":"sps","low":8,"high":860},"I (continuous mode)":{"unit":"uA","typical":150},"I2C Addresses":{"unit":"address","low":"0x48","high":"0x4B"}},"Platforms":{"Intel Joule Module":{"Notes":["On DFRobot Gravity Expansion Shield for Intel Joule"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1085","https://www.dfrobot.com/product-1560.html"],"Datasheets":["http://www.ti.com/lit/ds/symlink/ads1115.pdf"],"Schematics":["https://learn.adafruit.com/adafruit-4-channel-adc-breakouts/signal-connections"]}}}},{"Library":"apa102","Description":"Adafruit apa102 iPixel LED library","Sensor Class":{"APA102":{"Name":"Adafruit apa102 iPixel LED","Description":"This is the UPM Module for the Adafruit apa102 LED. This RGB LED package offers a PWM interface for fine tuning of colors, as well as offering shifting. Each LED module can read the top layer of commands, before shifting the next layer to the next LED, allowing you to communicate to a large string of LEDs.","Aliases":["apa102","iPixel LED","APA102 5050 RGB LED with integrated driver chip"],"Categories":["led"],"Connections":["SPI"],"Project Type":["prototyping","commercial"],"Manufacturers":["Shiji Lighting","Adafruit"],"Image":"apa102.jpg","Examples":{"Java":["apa102.java"],"Python":["apa102.py"],"Node.js":["apa102.js"],"C++":["apa102.cxx"]},"Specifications":{"Vdd":{"unit":"V","min":5,"max":5.5},"Supply Current Digital":{"Normal mode":{"unit":"mA","min":"22.5","max":"26.5"}},"Operating Temperature":{"unit":"°C","min":-40,"max":70}},"Urls":{"Product Pages":["https://www.adafruit.com/product/2343"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/APA102.pdf"]}}}},{"Library":"apds9002","Description":"Seeed luminance sensor library","Sensor Class":{"APDS9002":{"Name":"Seeed luminance sensor","Description":"This is the UPM Module for the apds9002, Seeed luminance sensor. This sensor offers a luminance sensor solution that has a responsitivity close to that of the human eye. Operates at 3.3 and 5 volts on a Seeed standard breakout board.","Aliases":["apds9002","Grove - Luminance Sensor"],"Categories":["light"],"Connections":["Analog"],"Project Type":["prototyping","mobile"],"Manufacturers":["Avago","Seeed"],"Image":"apds9002.jpg","Examples":{"Java":["apds9002.java"],"Python":["apds9002.py"],"Node.js":["apds9002.js"],"C++":["apds9002.cxx"]},"Specifications":{"Vdd":{"unit":"V","min":2.4,"max":5.5},"Measurement range":{"unit":"Lux","min":"0","max":"1000"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Rise time":{"unit":"ms","typ":0.95,"max":2},"Fall time":{"unit":"ms","typ":0.8,"max":2}},"Platforms":{"Intel Edison":{"Notes":["Might require Seeed breakout board"]},"Arduino 101":{"Notes":["Might require Seeed breakout board"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Luminance-Sensor-p-1941.html"],"Datasheets":["http://www.mouser.com/ds/2/678/V02-3579EN-DS-APDS-9002-11Jun20120-909745.pdf"]}}}},{"Library":"apds9930","Description":"SparkFun apds9930 ambient light and color sensor library","Sensor Class":{"APDS9930":{"Name":"SparkFun apds9930 ambient light and color sensor","Description":"This is the UPM Module for the SparkFun RGB and ambient light sensor. This sensor also has gesture and proximity detection, coupled with IR and UV filters to reduce background noise. Uses i2c to communicate and can operate on 3.3 volts.","Aliases":["apds9930","SparkFun RGB and Gesture Sensor - APDS-9960"],"Categories":["light","proximity"],"Connections":["iio","i2c"],"Project Type":["prototyping","mobile","robotics"],"Manufacturers":["Avago","SparkFun"],"Image":"apds9930.jpg","Examples":{"C++":["apds9930.cxx"]},"Specifications":{"Vdd":{"unit":"V","min":2.4,"max":3.8},"Supply Current Digital":{"Normal Mode":{"unit":"uA","min":"38.0","max":"790"},"Sleep mode":{"unit":"uA","typ":"1.0"}},"Operating Temperature":{"unit":"°C","min":-30,"max":85}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/12787"],"Datasheets":["https://cdn.sparkfun.com/datasheets/Sensors/Proximity/apds9960.pdf"]}}}},{"Library":"at42qt1070","Description":"Atmel Touch Sensor library","Sensor Class":{"AT42QT1070":{"Name":"Atmel AT42QT1070 touch sensor","Description":"This is the UPM Module for the Atmel at42qt1070 touch sensor. This sensor is a single touch capacitive sensor, able to detect when a capacitive load is applied to one of the five pins offered. It has extensive exernal noise and RF suppression built in. When a capacitive load is detected, the corrisponding output is pulled low until the load is eliminated.","Aliases":["at42qt1070","Grove-Q Touch Sensor"],"Categories":["touch"],"Connections":["i2c"],"Project Type":["prototyping"],"Manufacturers":["Atmel","Seeed"],"Image":"at42qt1070.jpg","Examples":{"Python":["at42qt1070.py"],"Node.js":["at42qt1070.js"],"C++":["at42qt1070.cxx"]},"Specifications":{"Vdd":{"unit":"V","min":1.8,"max":5.5},"Supply Current Digital":{"3.3 Vdc":{"unit":"mA","min":"0.0","max":"1.0"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Capacitance":{"unit":"pF","min":1,"max":30}},"Platforms":{"Intel Edison":{"Notes":["Might require Seeed breakout board"]},"Arduino 101":{"Notes":["Might require Seeed breakout board"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Q-Touch-Sensor-p-1854.html"],"Datasheets":["http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-9596-AT42-QTouch-BSW-AT42QT1070_Datasheet.pdf"]}}}},{"Library":"bh1750","Description":"DFRobot BH1750 light intensity sensor library","Sensor Class":{"BH1750":{"Name":"DFRobot BH1750 light intensity sensor","Description":"This is the UPM Module for the DFRobot bh1750 light intensity sensor. This sensor outputs light level data directly in Lux(Lx), eliminating complicated voltage calculations from your program. Offers a large range of Lx sensativity, with high resolution and i2c communication.","Aliases":["bh1750","DFRobot - Light Sensor - BH1750"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["DFRobot","Rohm"],"Image":"bh1750.jpg","Examples":{"Java":["BH1750_Example.java"],"Python":["bh1750"],"Node.js":["bh1750.js"],"C++":["bh1750.cxx"],"C":["bh1750.c"]},"Specifications":{"Vdd":{"unit":"V","min":3,"max":5},"Supply Current Digital":{"Normal mode":{"unit":"uA","typ":"120","max":"190"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Detection Range":{"unit":"Lux","min":1,"max":65535}},"Urls":{"Product Pages":["https://www.dfrobot.com/product-531.html"],"Datasheets":["http://image.dfrobot.com/image/data/SEN0097/BH1750FVI.pdf"]}}}},{"Library":"biss0001","Description":"Seeed PIR motion sensor library","Sensor Class":{"BISS0001":{"Name":"Seeed BISS0001 PIR motion detector","Description":"This is the UPM Module for the Seeed BISS0001 PIR motion detector. This sensor offers a 120 degree sensor arc, with a 3 to 6 meter detecting distance. It also offers adjustable detecting distance and hold times.","Aliases":["biss0001","Grove - PIR Motion Sensor"],"Categories":["light"],"Connections":["GPIO"],"Project Type":["prototyping","home","industrial"],"Manufacturers":["seeed"],"Kits":["tsk"],"Image":"biss0001.jpg","Examples":{"Java":["BISS0001Sample.java"],"Python":["biss0001.py"],"Node.js":["biss0001.js"],"C++":["biss0001.cxx"],"C":["biss0001.c"]},"Specifications":{"Vdd":{"unit":"V","min":3,"max":5},"Supply Current Digital":{"5.0 Vdc":{"unit":"mA","typ":"10"}},"Operating Temperature":{"unit":"°C","min":-20,"max":70},"Storage Temperature":{"unit":"°C","min":-40,"max":125},"Response Time Digital":{"unit":"s","min":0.3,"max":25},"Detecting angle":{"unit":"degrees","angle":120},"Detecting distance":{"unit":"m","min":3,"max":6}},"Platforms":{"Intel Edison":{"Notes":["Requires Seeed expansion board"]},"Arduino 101":{"Notes":["Requires Seeed expansion board"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-PIR-Motion-Sensor-p-802.html"],"Datasheets":["http://wiki.seeedstudio.com/images/2/2f/Twig_-_BISS0001.pdf"]}}}},{"Library":"bma220","Description":"Bosch Sensortec accelerometer library","Sensor Class":{"BMA220":{"Name":"Bosch BMA220 accelerometer","Description":"This is the UPM Module for the Bosch BMA220 accelerometer. A triaxis accelerometer which measures acceleration in three perpendicular axes. It offers interruption pins, as well as motion interrupts, which can be triggered via orientation, shock, or taps. DFRobot offers this on an evaluation board, known as SEN0168.","Aliases":["BMA220","DFRobot SEN0168"],"Categories":["accelerometer"],"Connections":["i2c","gpio"],"Project Type":["industrial","commercial","prototyping"],"Manufacturers":["bosch"],"Image":"bma220.jpg","Examples":{"Python":["bma220.py"],"Node.js":["bma220.js"],"C++":["bma220.cxx"]},"Specifications":{"Vdd":{"unit":"V","min":1.62,"max":1.98},"Supply Current Digital":{"Normal mode":{"unit":"uA","typ":"250"},"Low power mode":{"unit":"uA","typ":"10"},"Suspend mode":{"unit":"uA","min":"<1"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Wake-up time":{"unit":"ms","max":1.2},"Start-up time":{"unit":"ms","typ":1.5}},"Urls":{"Product Pages":["http://www.mouser.com/ProductDetail/Bosch-Sensortec/BMA220/?qs=d72FGnIDsgT670fCZvhfag%3D%3D"],"Datasheets":["http://www.mouser.com/ds/2/783/BST-BMA220-DS003-08-838368.pdf"]}}}},{"Library":"bma250e","Description":"Bosch Sensortec accelerometer library","Sensor Class":{"BMA250E":{"Name":"Bosch BMA250E accelerometer","Description":"This is the UPM Module for the Bosch BMA250E accelerometer. This sensor offers triaxial low-g acceleration detection, and offers spi and i2c interfaces. It also offers interrupts, which can be activated by input, such as new data, motion, taps, or even different orientations.","Aliases":["bma250e"],"Categories":["accelerometer"],"Connections":["i2c","spi","gpio"],"Project Type":["industrial","commercial"],"Manufacturers":["bosch"],"Image":"bma250e.jpg","Examples":{"Java":["BMA250E_Example.java"],"Python":["bma250e.py"],"Node.js":["bma250e.js"],"C++":["bma250e.cxx"],"C":["bma250e.c"]},"Specifications":{"Vdd":{"unit":"V","min":1.62,"max":3.6},"Supply Current Digital":{"Normal mode":{"unit":"uA","typ":"130"},"Suspend mode":{"unit":"uA","typ":"2.1"},"Deep suspend mode":{"unit":"uA","typ":"1"},"Low-power mode 1":{"unit":"uA","typ":"6.5"},"Low-power mode 2":{"unit":"uA","typ":"66"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start-up time":{"unit":"ms","max":"1.2"},"Wake-up time 1":{"unit":"ms","typ":"1.3","max":"1.8"},"Wake-up time 2":{"unit":"ms","typ":"1","max":"1.2"}},"Urls":{"Product Pages":["https://www.bosch-sensortec.com/bst/products/all_products/bma250e"],"Datasheets":["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMA250E-DS004-06.pdf"]}}}},{"Library":"bmg","Description":"Bosch Sensortec 3-axis gyroscope library","Sensor Class":{"BMG160":{"Name":"Bosch 3-Axis gyroscope","Description":"This is the UPM Module for the Bosch BMG160 3-Axis gyroscope. Offers 16 bit digital resolution, with 5 scale ranges. Supports interrupts and low power modes. Offers i2c and SPI interfaces.","Aliases":["bmg160"],"Categories":["gyroscope"],"Connections":["i2c","spi","gpio"],"Project Type":["industrial","commercial"],"Manufacturers":["bosch"],"Image":"bmg160.jpg","Examples":{"Java":["BMG160_Example.java"],"Python":["bmg160.py"],"Node.js":["bmg160.js"],"C++":["bmg160.cxx"],"C":["bmg160.c"]},"Specifications":{"Vdd":{"unit":"V","min":2.4,"max":3.6},"Supply Current Digital":{"Normal mode":{"unit":"mA","typ":"2.5"},"Sleep mode":{"unit":"uA","typ":"25"},"Deep sleep mode":{"unit":"uA","typ":"<5"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start up time":{"unit":"ms","time":3},"Wake-up time":{"unit":"ms","min":10,"max":30}},"Urls":{"Product Pages":["https://www.bosch-sensortec.com/bst/products/all_products/bmg160"],"Datasheets":["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMG160-DS000-09.pdf"]}}}},{"Library":"bmi160","Description":"Bosch Sensortec accelerometer and gyroscope library.","Sensor Class":{"BMI160":{"Name":"Bosch accelerometer and gyroscope","Description":"This is the UPM Module for the BMI160 Bosch low power inertial measurement unit. High performance hardware synchronized accelerometer and gyroscope, with very low power consumption. Extended i2c mode with 1 MHz clock frequencies. This sensor is able to handle external sensor data from other Bosch sensors.","Aliases":["BMI160"],"Categories":["accelerometer","gyroscope","compass"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["bosch"],"Image":"bmi160.jpg","Examples":{"Java":["BMI190_Example.java"],"Python":["bmi160.py"],"Node.js":["bmi160.js"],"C++":["bmi160.cxx"],"C":["bmi160.c"]},"Specifications":{"Vdd":{"unit":"V","min":1.71,"max":3.6},"Supply Current Digital":{"Full operation":{"unit":"uA","typ":"925","max":"990"},"Suspended mode":{"unit":"uA","typ":"3","max":"10"},"Significant motion detection":{"unit":"uA","max":"20"},"Step detector":{"unit":"uA","max":"20"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start up time accelerometer":{"unit":"ms","time":3.2},"Response time gyroscope":{"unit":"ms","time":55}},"Urls":{"Product Pages":["https://www.bosch-sensortec.com/bst/products/all_products/bmi160"],"Datasheets":["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMI160-DS000-07.pdf"]}}}},{"Library":"bmp280","Description":"Bosch Atmospheric Sensor Library","Sensor Class":{"BME280":{"Name":"Digital Humidity, Pressure, and Temperature Sensor","Description":"The BME280 is as combined digital humidity, pressure and temperature sensor based on proven sensing principles. The sensor module is housed in an extremely compact metal-lid LGA package with a footprint of only 2.5 * 2.5 mm2 with a height of 0.93 mm. Its small dimensions and its low power consumption allow the implementation in battery driven devices such as handsets, GPS modules or watches. The BME280 is register and performance compatible to the Bosch Sensortec BMP280 digital pressure sensor","Aliases":["bme280","Grove - Barometer Sensor(BME280)"],"Categories":["pressure","humidity","temperature"],"Connections":["gpio","i2c","spi"],"Project Type":["prototyping","industrial"],"Manufacturers":["adafruit","seeed","bosch"],"Image":"bmp280.jpg","Examples":{"Java":["BMP280_Example.java"],"Python":["bmp280.py"],"Node.js":["bmp280.js"],"C++":["bmp280.cxx"],"C":["bmp280.c"]},"Specifications":{"Vdd":{"unit":"v","low":1.7,"high":3.6},"Ioff":{"unit":"mA","low":0,"high":0},"Iavg":{"unit":"mA","low":1,"high":2},"Pressure Range":{"unit":"hpA","low":300,"high":1100},"Temperature Range":{"unit":"C","low":-40,"high":85}},"Platforms":{"Intel Joule Module":{"Notes":["Requires pull-up resistors with carrier board"]}},"Urls":{"Product Pages":["https://www.adafruit.com/products/2652"],"Datasheets":["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-11.pdf"],"Schematics":["https://learn.adafruit.com/assets/26693"]}},"BMP280":{"Name":"Digital Pressure Sensor","Description":"The BMP280 is an absolute barometric pressure sensor especially designed for mobile applications. The sensor module is housed in an extremely compact 8-pin metal-lid LGA package with a footprint of only 2.0 * 2.5 mm2 and 0.95 mm package height. Its small dimensions and its low power consumption of 2.7 uA @1Hz allow the implementation in battery driven devices such as mobile phones, GPS modules or watches. As the successor to the widely adopted BMP180, the BMP280 delivers high performance in all applications that require precise pressure measurement. The BMP280 operates at lower noise, supports new filter modes and an SPI interface within a footprint 63% smaller than the BMP180.","Aliases":["bmp280","Grove - Barometer Sensor (BMP280)"],"Categories":["pressure","humidity","temperature"],"Connections":["gpio","i2c","spi"],"Project Type":["prototyping","industrial"],"Manufacturers":["adafruit","seeed","bosch"],"Image":"bmp280.jpg","Examples":{"Java":["BME280_Example.java","BME280_InterfaceExample"],"Python":["bme280.py"],"Node.js":["bme280.js"],"C++":["bmp280-bme280.cxx"],"C":["bmp280-bme280.c"]},"Specifications":{"Vdd":{"unit":"v","low":1.7,"high":3.6},"Ioff":{"unit":"mA","low":0,"high":0},"Iavg":{"unit":"mA","low":1,"high":2},"Pressure Range":{"unit":"hpA","low":300,"high":1100},"Temperature Range":{"unit":"C","low":-40,"high":85}},"Platforms":{"Intel Joule Module":{"Notes":["Requires pull-up resistors with carrier board"]}},"Urls":{"Product Pages":["https://www.adafruit.com/products/2651"],"Datasheets":["https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BMP280-DS001-18.pdf"],"Schematics":["https://learn.adafruit.com/assets/26693"]}}}},{"Library":"button","Description":"Generic library for buttons & switches","Sensor Class":{"Button":{"Name":"Button","Description":"Basic UPM module for buttons and switches. Allows attaching a callback function to state transitions.","Aliases":["Grove - Button"],"Categories":["button"],"Connections":["gpio"],"Project Type":["prototyping","industrial"],"Manufacturers":["seeed","dfrobot","sparkfun","adafruit","generic"],"Kits":["gsk"],"Image":"button.jpg","Examples":{"Java":["ButtonSample.java","Button_intrSample.java"],"Python":["button.py"],"Node.js":["button.js"],"C++":["button.cxx"],"C":["button.c","button-intr.c"]},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-Button/"],"Schematics":["https://easyeda.com/Seeed/Grove_Button_v1_2-f0f9f212fcee460ebe3703dab813e5c4"]}}}},{"Library":"buzzer","Description":"Generic library for piezoelectric buzzers","Sensor Class":{"Buzzer":{"Name":"Buzzer","Description":"This module defines the Buzzer interface for libbuzzer. This sensor can make different tones when connected to a pin capable of analog pulse-width modulation. It emits sound using a piezoelectric material that vibrates at different frequencies based on the input voltage.","Aliases":["Grove - Buzzer"],"Categories":["sound"],"Connections":["pwm"],"Project Type":["prototyping","industrial"],"Manufacturers":["seeed","dfrobot","sparkfun","adafruit","generic"],"Kits":["gsk"],"Image":"buzzer.jpg","Examples":{"Java":["BuzzerSample.java"],"Python":["buzzer.py"],"Node.js":["buzzer.js"],"C++":["buzzer.cxx"],"C":["buzzer.c"]},"Platforms":{"Intel Edison":{"Notes":["Might not work correctly with early versions of MRAA/UPM libraries, please use the latest versions."]}},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-Buzzer/"],"Datasheets":["https://cdn.sparkfun.com/datasheets/Components/General/cem-1203-42-.pdf"],"Schematics":["https://easyeda.com/Seeed/Grove_Buzzer_v1_2-c713baf3c1774da39ce0c995544ce5da"]}}}},{"Library":"grove","Description":"Generic library for basic Grove sensors","Sensor Class":{"grovebase":{"Name":"Generic library for basic Grove sensors","Description":"This is the Generic UPM Module for basic Grove sensors. This library is now deprecated and replaced by individual libraries for every sensor.","Aliases":["grove","libupm-grove"],"Categories":["LED","light","relay","temperature","touch"],"Connections":["i2c","gpio","pwm","ainput"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Kits":["gsk","eak","hak"],"Examples":{"C++":["grovebutton.cxx"]},"Urls":{"Product Pages":["https://github.com/intel-iot-devkit/upm/tree/master/src/grove"]}},"grovebutton":{"Name":"API for the Grove Button","Description":"This is the UPM Module for the Grove button. This class is being replaced by the upm-button library and the Button class.","Aliases":["Grove Touch Sensor","Grove button"],"Categories":["touch"],"Connections":["gpio"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"grovebutton.jpg","Examples":{"Java":["GroveButtonSample.java","GroveButton_intrSample.java"],"Python":["grovebutton.py"],"Node.js":["grovebutton.js"],"C++":["grove-grovebutton.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":12},"Supply Current Digital":{"unit":"mA","min":5,"max":25},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Button-p-766.html","http://wiki.seeed.cc/Grove-Button/"],"Schematics":["https://github.com/SeeedDocument/Grove_Button/raw/master/resources/Grove_-_Button_v1.0_Source_File.zip"]}},"groveled":{"Name":"API for the Grove LED","Description":"This is the UPM Module for the Grove LED. This class is being replaced by the upm-led library and the Led class.","Aliases":["Grove LED","Grove – Chainable RGB Led V2.0"],"Categories":["LED"],"Connections":["gpio"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"groveled.jpg","Examples":{"Java":["GroveLEDSample.java","GroveLed_multiSample.java"],"Python":["groveled.py"],"Node.js":["groveled.js"],"C++":["grove-groveled.cxx","grove-groveled-multi.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.5,"max":7.5},"Supply Current":{"unit":"mA","min":20,"max":60},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-%E2%80%93-Chainable-RGB-Led-V2.0-p-2903.html","http://wiki.seeed.cc/Grove-Chainable_RGB_LED/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Chainable_RGB_LED/master/res/P9813_datasheet.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove-Chainable_RGB_LED/raw/master/res/Grove%20-%20Chainable%20RGB%20LED%20v2.0.zip"]}},"grovelight":{"Name":"API for the Grove Light Sensor","Description":"This is the UPM Module for the Grove Light Sensor. This class is being replaced by the upm-light library and the Light class.","Aliases":["grovelight","Grove - Light Sensor(P)"],"Categories":["light"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"grovelight.jpg","Examples":{"Java":["GroveLightSample.java"],"Python":["grovelight.py"],"Node.js":["grovelight.js"],"C++":["grove-grovelight.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5},"Supply Current":{"unit":"mA","min":0.5,"max":3},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Response Time":{"unit":"ms","min":20,"max":30}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Light-Sensor(P)-p-1253.html","http://wiki.seeed.cc/Grove-Light_Sensor/"],"Datasheets":["https://github.com/SeeedDocument/Grove_Light_Sensor/raw/master/res/LM358.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove_Light_Sensor/raw/master/resources/Grove%20-%20Light%20Sensor%28P%29%20v1.1.zip"]}},"groverelay":{"Name":"API for the Grove Relay","Description":"This is the UPM Module for the Grove relay switch. This class is being replaced by the upm-relay library and the Relay class.","Aliases":["groverelay","Grove - Relay"],"Categories":["relay"],"Connections":["gpio"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk","eak","hak"],"Image":"groverelay.jpg","Examples":{"Java":["GroveRelaySample.java"],"Python":["groverelay.py"],"Node.js":["groverelay.js"],"C++":["grove-groverelay.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","typ":100},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Relay Life":{"unit":"Cycle","cycles":100000},"Max Switching Voltage":{"AC":{"unit":"V","max":250},"DC":{"unit":"V","max":30}},"Max Switching Current":{"unit":"A","max":5}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Relay-p-769.html","http://wiki.seeed.cc/Grove-Relay/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Relay/master/res/Relay_Datasheet.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove-Relay/raw/master/res/Grove%20-%20Relay%20Schematic.pdf","https://github.com/SeeedDocument/Grove-Relay/raw/master/res/Grove%20-%20Relay%20PCB.pdf","https://raw.githubusercontent.com/SeeedDocument/Grove-Relay/master/res/Grove-Relay_Eagle_Files.zip"]}},"groverotary":{"Name":"API for the Grove Rotary Angle Sensor (Knob)","Description":"This is the UPM Module for the Grove Rotary Angle Sensor (Knob). This class is being replaced by the upm-rotary library and the Rotary class.","Aliases":["groverotary","Grove - Rotary Angle Sensor"],"Categories":["ainput"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"groverotary.jpg","Examples":{"Java":["GroveRotarySample.java"],"Python":["groverotary.py"],"Node.js":["groverotary.js"],"C++":["grove-groverotary.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.75,"max":5.25},"Supply Current":{"unit":"mA","typ":20},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Rotary Angle":{"unit":"°","min":0,"max":300}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Rotary-Angle-Sensor-p-770.html","http://wiki.seeed.cc/Grove-Rotary_Angle_Sensor/"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-Rotary_Angle_Sensor/master/res/Grove-Rotary_Angle_Sensor_Eagle_File.zip","https://raw.githubusercontent.com/SeeedDocument/Grove-Rotary_Angle_Sensor/master/res/Grove-Rotary_Angle_Sensor_v1.2.zip"]}},"groveslide":{"Name":"API for the Grove Slide Potentiometer","Description":"This is the UPM Module for the Grove Slide Potentiometer. This class is being replaced by the upm-slide library and the Slide class.","Aliases":["groveslide","Grove - Slide Potentiometer"],"Categories":["ainput"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Image":"groveslide.jpg","Examples":{"Java":["GroveSlideSample.java"],"Python":["groveslide.py"],"Node.js":["groveslide.js"],"C++":["grove-groveslide.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":30},"Supply Current":{"unit":"mA","max":30},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Sroke Length":{"unit":"mm","min":0,"max":30}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Slide-Potentiometer-p-1196.html?gclid=Cj0KCQjw5arMBRDzARIsAAqmJexy5Nrps6rpUqNFk4iIL6mVfHQt7EYfly4NbdhC7wBl4p3AxQZNkjIaAuN2EALw_wcB","http://wiki.seeed.cc/Grove-Slide_Potentiometer/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Slide_Potentiometer/master/res/Sliding_potentiometer_datasheet.pdf"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-Slide_Potentiometer/master/res/Sliding_Potentiometer.rar"]}},"grovetemp":{"Name":"API for the Grove Temperature Sensor","Description":"This is the UPM Module for the Grove Temperature Sensor. This class is being replaced by the upm-temperature library and the Temperature class.","Aliases":["groverelay","Grove - Temperature Sensor"],"Categories":["temperature"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"grovetemp.jpg","Examples":{"Java":["GroveTempSample.java"],"Python":["grovetemp.py"],"Node.js":["grovetemp.js"],"C++":["grove-grovetemp.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","typ":50},"Operating Temperature":{"unit":"°C","min":-40,"max":125},"Accuracy":{"unit":"+/- °C","accuracy":1.5}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Temperature-Sensor-p-774.html?gclid=Cj0KCQjw5arMBRDzARIsAAqmJexygEDSrIieYoG1C37j3HmOOx7PHjXlPsWxnQo7g1sCctC_VErW2IAaAvIHEALw_wcB","http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/"],"Datasheets":["https://github.com/SeeedDocument/Grove-Temperature_Sensor_V1.2/raw/master/res/NCP18WF104F03RC.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove-Temperature_Sensor_V1.2/raw/master/res/Grove_-_Temperature_sensor_v1.1.zip"]}}}},{"Library":"hlg150h","Description":"Light Controller Library","Sensor Class":{"HLG150H":{"Name":"Lighting Power Supply Controller","Description":"HLG series single output LED power supply features universal AC input, protection for short circuit, overload, over voltage and over temperature","Aliases":["hlg150h"],"Categories":["lightcontroller"],"Connections":["pwm"],"Project Type":["prototyping","industrial"],"Manufacturers":["meanwell"],"Image":"hlg150h.jpg","Examples":{"C++":["hlg150h.cxx"]},"Specifications":{"Vdd":{"unit":"v","low":1.7,"high":3.6},"Ioff":{"unit":"mA","low":0,"high":0},"Iavg":{"unit":"mA","low":1,"high":2},"Pressure Range":{"unit":"hpA","low":300,"high":1100},"Voltage Range":{"unit":"C","low":-40,"high":85}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.meanwell-web.com/en/product-info/ac-dc-power-supply/led-driver/101-180-w-led-driver/hlg-150h/product/HLG-150H-24B"],"Datasheets":["http://www.mouser.com/ds/2/260/r1755_3-1109742.pdf"],"Schematics":["http://www.mouser.com/ds/2/260/HLG-150H-SPEC-806071.pdf"]}}}},{"Library":"led","Description":"LED library","Sensor Class":{"Led":{"Name":"Light-emitting Diode (LED)","Description":"UPM module for the LED (or other similar light-emitting diodes). An LED is a p-n junction semiconductor which emits light in response to voltage. The longer wire of an LED connects to the positive seat (anode); the shorter wire connects to the negative seat (cathode). The flat side of the bulb corresponds to the cathode, while the rounded side corresponds to the anode.","Aliases":["Grove - LED"],"Categories":["led"],"Connections":["gpio"],"Project Type":["prototyping","industrial"],"Manufacturers":["seeed","dfrobot","sparkfun","adafruit","generic"],"Kits":["gsk"],"Image":"led.jpg","Examples":{"Java":["LEDSample.java"],"Python":["led.py"],"Node.js":["led.js"],"C++":["led.cxx"],"C":["led.c"]},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-LED_Socket_Kit/"],"Schematics":["https://github.com/SeeedDocument/Grove-LED_Socket_Kit/raw/master/res/Grove-LED_v1.3_Schematics.zip"]}}}},{"Library":"lp8860","Description":"LED Light Controller Library","Sensor Class":{"LP8860":{"Name":"API for LP8860 LED Lighting Controller","Description":"The LP8860-Q1 is an automotive high-efficiency LED driver with boost controller. It has 4 high-precision current sinks that can be controlled by a PWM input signal, an SPI or I2C master, or both ","Aliases":["lp8860"],"Categories":["light Controller"],"Connections":["i2c"],"Project Type":["prototyping","industrial"],"Manufacturers":["Texas Instruments"],"Image":"","Examples":{"C++":["lp8860.cxx"]},"Specifications":{"Vdd":{"unit":"v","low":3,"high":48},"Iavg":{"unit":"mA","low":1,"high":150},"Frequency Range":{"unit":"KHz","low":100,"high":2200},"Temperature Range":{"unit":"C","low":-40,"high":125}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://www.ti.com/product/LP8860-Q1"],"Datasheets":["http://www.ti.com/lit/ds/symlink/lp8860-q1.pdf"],"Schematics":["http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=LP8860-Q1&diagramId=66853"]}}}},{"Library":"max44009","Description":"Ambient Light Sensor Library","Sensor Class":{"MAX44009":{"Name":"Digital Humidity, Pressure, and Temperature Sensor","Description":"The MAX44009 ambient light sensor features an i2c digital output that is ideal for a number of portable applications such as smartphones, notebooks and industrial sensors","Aliases":["max44009"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping","industrial"],"Manufacturers":["Maxim integrated"],"Image":"","Examples":{"C++":["max44009.cxx"]},"Specifications":{"Vdd":{"unit":"v","low":1.7,"high":3.6},"Temperature Range":{"unit":"C","low":-40,"high":85},"Dynamic Range":{"unit":"lux","low":0.045,"high":188000}},"Platforms":{"Intel Joule Module":{"Notes":["might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maximintegrated.com/en/products/analog/sensors-and-sensor-interface/MAX44009.html"],"Datasheets":["https://datasheets.maximintegrated.com/en/ds/MAX44009.pdf"]}}}},{"Library":"max5487","Description":"MAX5487 Digital Potentiometer library","Sensor Class":{"MAX5487":{"Name":"MAX5487 Digital Potentiometer","Description":"This is the UPM Module for the Maxim dual, linear-taper, digital potentiometer. It offers 256 Tap positions, as well as a 10 kiloohm end to end resistance. It interfaces using 3 wire spi, and feature nonvolatile memory.","Aliases":["max5487","MAX5487 Dual, 256-Tap, Nonvolatile, SPI-Interface, Linear-Taper Digital Potentiometers"],"Categories":["digital potentiometer"],"Connections":["spi"],"Project Type":["prototyping","commercial"],"Manufacturers":["maxim"],"Image":"max5487.jpg","Examples":{"Java":["MAX5487Example.java"],"C++":["max5487.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.7,"max":5.25},"Supply Current":{"unit":"uA","min":"0.5","max":"400"},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maximintegrated.com/en/products/analog/data-converters/digital-potentiometers/MAX5487.html"],"Datasheets":["https://datasheets.maximintegrated.com/en/ds/MAX5487-MAX5489.pdf"]}}}},{"Library":"maxds3231m","Description":"maxds3231m Realtime Clock (RTC) Sensor Library","Sensor Class":{"MAXDS3231M":{"Name":"maxds3231m Realtime Clock (RTC) Sensor","Description":"This is the UPM Module for the Maxim Realtime Clock module. It offers i2c connectivity, with a temperature compensated crystal and crystal oscillator. It offers 12 and 24 hour clock formats, as built in battery backup support.","Aliases":["maxds3231m","DS3231","DS3231 Extremely Accurate I2C-Integrated RTC/TCXO/Crystal"],"Categories":["RTC"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Maxim"],"Image":"maxds3231m.jpg","Examples":{"Java":["MAXds3231mExample.java"],"C++":["maxds3231m.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.3,"max":5.5},"Supply Current":{"unit":"uA","min":130,"max":650},"Operating Temperature":{"unit":"°C","min":-45,"max":85},"Compensated Temperature Range":{"unit":"°C","min":0,"max":40}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maximintegrated.com/en/products/digital/real-time-clocks/DS3231.html"],"Datasheets":["https://datasheets.maximintegrated.com/en/ds/DS3231M.pdf"]}}}},{"Library":"maxsonarez","Description":"API for the MaxBotix LV-MaxSonar-EZ Family of Ultrasonic Rangers","Sensor Class":{"EZ0":{"Name":"LV-MaxSonar-EZ0 Ultrasonic range finder","Description":"This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ0 offers the widest beam of the EZ collection.","Aliases":["maxsonarez","LV-MaxSonar-EZ0","MB1000 LV-MaxSonar-EZ0"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["MaxBotix"],"Image":"maxsonarez.jpg","Examples":{"Python":["maxsonarez.py"],"Node.js":["maxsonarez.js"],"C++":["maxsonarez.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"mA","Typ":"2"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Range":{"unit":"cm","min":"15.24","max":"645"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maxbotix.com/Ultrasonic_Sensors/MB1000.htm"],"Datasheets":["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]}},"EZ1":{"Name":"LV-MaxSonar-EZ1 Ultrasonic range finder","Description":"This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ1 offers the second widest beam of the EZ collection, as well as high sensativity and side object rejectoin.","Aliases":["maxsonarez","LV-MaxSonar-EZ1","MB1010 LV-MaxSonar-EZ1"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["MaxBotix"],"Image":"maxsonarez.jpg","Examples":{"Python":["maxsonarez.py"],"Node.js":["maxsonarez.js"],"C++":["maxsonarez.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"mA","Typ":"2"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Range":{"unit":"cm","min":"15.24","max":"645"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maxbotix.com/Ultrasonic_Sensors/MB1010.htm"],"Datasheets":["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]}},"EZ2":{"Name":"LV-MaxSonar-EZ2 Ultrasonic range finder","Description":"This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ2 offers a good balance of high sensativity and side object rejection.","Aliases":["maxsonarez","LV-MaxSonar-EZ2","MB1020 LV-MaxSonar-EZ2"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["MaxBotix"],"Image":"maxsonarez.jpg","Examples":{"Python":["maxsonarez.py"],"Node.js":["maxsonarez.js"],"C++":["maxsonarez.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"mA","Typ":"2"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Range":{"unit":"cm","min":"15.24","max":"645"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maxbotix.com/Ultrasonic_Sensors/MB1020.htm"],"Datasheets":["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]}},"EZ3":{"Name":"LV-MaxSonar-EZ3 Ultrasonic range finder","Description":"This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ3 offers a very narrow beam, with good side object rejection.","Aliases":["maxsonarez","LV-MaxSonar-EZ3","MB1030 LV-MaxSonar-EZ3"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["MaxBotix"],"Image":"maxsonarez.jpg","Examples":{"Python":["maxsonarez.py"],"Node.js":["maxsonarez.js"],"C++":["maxsonarez.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"mA","Typ":"2"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Range":{"unit":"cm","min":"15.24","max":"645"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maxbotix.com/Ultrasonic_Sensors/MB1030.htm"],"Datasheets":["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]}},"EZ4":{"Name":"LV-MaxSonar-EZ4 Ultrasonic range finder","Description":"This is the UPM Module for the MaxBotix Ultrasonic Range Finder series. The EZ4 is the narrowest beam sensor, with the best side object rejection, which provides good detection for large objects.","Aliases":["maxsonarez","LV-MaxSonar-EZ4","MB1040 LV-MaxSonar-EZ4"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["MaxBotix"],"Image":"maxsonarez.jpg","Examples":{"Python":["maxsonarez.py"],"Node.js":["maxsonarez.js"],"C++":["maxsonarez.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"mA","Typ":"2"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Range":{"unit":"cm","min":"15.24","max":"645"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.maxbotix.com/Ultrasonic_Sensors/MB1040.htm"],"Datasheets":["http://www.maxbotix.com/documents/LV-MaxSonar-EZ_Datasheet.pdf"]}}}},{"Library":"mb704x","Description":"API for the MaxBotix MB704x MaxSonar-WR Ultrasonic Ranger","Sensor Class":{"MB704X":{"Name":"MB704x MaxSonar-WR Ultrasonic Ranger","Description":"This is the UPM Module for the API for the MB704x MaxSonar-WR Ultrasonic Ranger. It was tested with a long distance weather resistant horn, others are offered however giving this sensor a large range of uses.","Aliases":["MB704x","MB704x MaxSonar-WR Ultrasonic Ranger"],"Categories":["sound"],"Connections":["i2c"],"Project Type":["prototyping","industrial"],"Manufacturers":["MaxBotix"],"Image":"mb704x.jpg","Examples":{"Java":["MB704X_Example.java"],"Python":["mb704x.py"],"Node.js":["mb704x.js"],"C++":["mb704x.cxx"],"C":["mb704x.c"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5.5},"Supply Current":{"unit":"mA","Typ":"3.4"},"Operating Temperature":{"unit":"°C","min":-40,"max":70},"Effective Range":{"unit":"cm","min":"20","max":"765"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://www.maxbotix.com/Ultrasonic_Sensors/I2C_Distance_Sensors.htm"],"Datasheets":["https://www.maxbotix.com/documents/I2CXL-MaxSonar-WR_Datasheet.pdf"]}}}},{"Library":"mcp2515","Description":"API for the Microchip MCP2515 CAN bus controller","Sensor Class":{"MCP2515":{"Name":"Microchip MCP2515 CAN bus controller","Description":"This is the UPM Module for the Microchip MCP2515 CAN bus controller. This Arduino/Genuino compatable shield offers the ability to communicate over CAN-BUS. This offers a good medium speed, long distance and high reliablity communication solution for Arduino/Genuino projects.","Aliases":["mcp2515","CAN-BUS Shield V1.2"],"Categories":["communication"],"Connections":["spi","gpio"],"Project Type":["prototyping"],"Manufacturers":["Seeed","Microchip"],"Image":"mcp2515.jpg","Examples":{"Java":["MCP2515_Example.java","MCP2515_TXRX_Example.java"],"Python":["mcp2515-txrx.py","mcp2515.py"],"Node.js":["mcp2515-txrx.js","mcp2515.js"],"C++":["mcp2515-txrx.cxx","mcp2515.cxx"],"C":["mcp2515-txrx.c","mcp2515.c"]},"Specifications":{"Vsource":{"unit":"V","min":2.7,"max":5.5},"Supply Current":{"Normal Mode":{"unit":"mA","Typ":"10"},"Sleep Mode":{"unit":"uA","min":"5","max":"8"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Data Frame Buffer":{"unit":"bit","min":"11","max":"29"}},"Platforms":{"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.seeedstudio.com/CANBUS-Shield-p-2256.html"],"Datasheets":["http://ww1.microchip.com/downloads/en/DeviceDoc/21801e.pdf"]}}}},{"Library":"mcp9808","Description":"MCP9808 precision temperature sensor library","Sensor Class":{"MCP9808":{"Name":"Microchip MCP9808 precision temperature sensor","Description":"This is the UPM Module for the Microchip MCP9808 precision temperature sensor. The MCP9808 digital temperature sensor converts temperatures between -20 deg C and +100 deg C to a digital word with +/- 0.5 deg C (max.) accuracy. The MCP9808 comes with user-programmable registers that provide flexibility for temperature sensing applications. The registers allow user-selectable settings such as Shutdown or low-power modes and the specification of temperature Event and Critical output boundaries. When the temperature changes beyond the specified boundary limits, the MCP9808 outputs an Event signal. The user has the option of setting the event output signal polarity as an active-low or active-high comparator output for thermostat operation, or as temperature event interrupt outputfor microprocessor-based systems. The event output can also be configured as a Critical temperature output.","Aliases":["mcp9808","MCP9808 High Accuracy I2C Temperature Sensor Breakout Board"],"Categories":["temperature"],"Connections":["i2c"],"Project Type":["prototyping"],"Manufacturers":["Microchip","Adafruit"],"Image":"mcp9808.jpg","Examples":{"Node.js":["mcp9808.js"],"C++":["mcp9808.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.7,"max":5.5},"Supply Current":{"unit":"uA","min":200,"max":400},"Operating Temperature":{"unit":"°C","min":-40,"max":125},"0.25 °C Prescision":{"unit":"°C","min":-40,"max":125},"0.5 °C Prescision":{"unit":"°C","min":-20,"max":100}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1782?gclid=Cj0KCQjwnubLBRC_ARIsAASsNNkm7dgo3LX4XplesneIFqkY63M7rmfcdlPYq7JXYpuIqnfuEGljSdYaAsILEALw_wcB"],"Datasheets":["http://ww1.microchip.com/downloads/en/DeviceDoc/25095A.pdf"]}}}},{"Library":"md","Description":"I2C Motor Driver library","Sensor Class":{"MD":{"Name":"Grove I2C Motor Driver","Description":"This class implements support for the I2C Motor Driver. This device can support a single 4-wire stepper motor, or two 2-wire DC motors. The device contains an Atmel* ATmega8L microcontroller that manages an L298N H-bridge driver chip. This device supports an I2C bus speed of 100Khz only. The module does not provide any telemetry or status - it only accepts I2C commands for its various operations. This module was tested with version 1.3 of the I2C Motor Driver. For stepper operation, this driver can run in one of two modes - Mode 1, where this driver handles the stepping operation, and Mode 2, where this driver simply sends commands to the Motor Driver, and it handles the stepping operation. Mode2 requires updated (and working) firmware to be loaded onto the device. The default stepper operation mode is Mode1, which is generally more flexible and is supported on all firmware revisions.","Aliases":["Grove - I2C Motor Driver"],"Categories":["motor"],"Connections":["i2c"],"Project Type":["prototyping","robotics"],"Manufacturers":["Seeed"],"Kits":["robok"],"Image":"md.jpg","Examples":{"Java":["GroveMDSample.java"],"Python":["grovemd-stepper.py","grovemd.py"],"Node.js":["md-stepper.js","md.js"],"C++":["md-stepper.cxx","md.cxx"],"C":["md-stepper.c","md.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"A","min":0.5,"max":4},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Requires Grove Shield"]},"Arduino 101":{"Notes":["Requires Grove Shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-I2C-Motor-Driver-p-907.html"],"Datasheets":["http://wiki.seeed.cc/Grove-I2C_Motor_Driver_V1.3/"]}}}},{"Library":"mg811","Description":"API for the DFRobot CO2 Sensor","Sensor Class":{"MG811":{"Name":"DFRobot CO2 Sensor","Description":"This sensor returns an an analog voltage that falls as the concentration of CO2 increases.  It contains a heater that must be allowed to 'warm' up the sensor before measurements are stable (hours to days is the recommendation).  It requires that the MCU be powered from an external power supply (not USB) at 5v, since the heater will consume significant current. The sensor should be allowed to 'heat' up for some time before beginning use, typically a couple of hours minimum.  It also needs fairly precise calibration at 400ppm and 1000ppm to return meaningful results. The sensor also incorporates a potentiometer that can be adjusted to specific threshold.  Once that threshold is reached, an LED on the sensor will light, and the digital pin will be driven high.","Aliases":["mg811","Gravity: Analog CO2 Gas Sensor For Arduino"],"Categories":["gaseous"],"Connections":["analog"],"Project Type":["prototype","industrial","commercial"],"Manufacturers":["dfrobot"],"Image":"mg811.jpg","Examples":{"Python":["mg811.py"],"Node.js":["mg811.js"],"C++":["mg811.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":0,"max":5},"Supply Current":{"unit":"mA","typ":200},"Operating Temperature":{"unit":"°C","min":-20,"max":50},"Effective Range":{"unit":"ppm","min":"350","max":"10,000"}},"Platforms":{"Intel Edison":{"Notes":["Requires the Gravity: IO Expansion Shield for Arduino V7.1"]},"Arduino 101":{"Notes":["Requires the Gravity: IO Expansion Shield for Arduino V7.1"]}},"Urls":{"Product Pages":["https://www.dfrobot.com/product-1023.html"],"Datasheets":["http://image.dfrobot.com/image/data/SEN0159/CO2b%20MG811%20datasheet.pdf"]}}}},{"Library":"mhz16","Description":"MHZ16 Serial CO2 Sensor library","Sensor Class":{"MHZ16":{"Name":"MHZ16 Serial CO2 Sensor library","Description":"This is the UPM Module for the Seeed/Zhengzhou Winsen Electronics Technology MHZ16 Serial CO2 Sensor. This class implements support for the Grove CO2 sensor. Its CO2 detection range is 0-2,000 ppm. It requires a 2-3 minute warm-up time before reporting valid data.","Aliases":["Grove - CO2 Sensor","MH-Z16 Intelligent Infrared Gas Module"],"Categories":["gaseous"],"Connections":["uart"],"Project Type":["industrial","commercial"],"Manufacturers":["Seeed","Zhengzhou Winsen Electronics Technology"],"Image":"mhz16.jpg","Examples":{"Java":["MHZ16Sample.java"],"Python":["mhz16.py"],"Node.js":["mhz16.js"],"C++":["mhz16.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.5,"max":6},"Supply Current":{"unit":"mA","min":"50","max":"100"},"Operating Temperature":{"unit":"°C","min":0,"max":50},"Response Time":{"unit":"s","time":"<90"},"Warm-up Time":{"unit":"minute","time":3},"Effective Range":{"unit":"ppm","min":0,"max":2000},"Accuracy":{"unit":"ppm","accuracy":200},"Operating Humidity":{"unit":"RH","min":"0%","max":"90%"}},"Platforms":{"Intel Edison":{"Notes":["Requires Grove Arduino breakout board"]},"Arduino 101":{"Notes":["Requires Grove Arduino breakout board"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-CO2-Sensor-p-1863.html"],"Datasheets":["http://wiki.seeed.cc/Grove-CO2_Sensor/","https://raw.githubusercontent.com/SeeedDocument/Grove-CO2_Sensor/master/res/MH-Z16_CO2_datasheet_EN.pdf"]}}}},{"Library":"mic","Description":"Generic analog microphone library","Sensor Class":{"Microphone":{"Name":"Analog Microphone","Description":"This module defines the Analog Microphone sensor.","Aliases":["Grove - Sound Sensor"],"Categories":["sound"],"Connections":["analog"],"Project Type":["prototyping","industrial"],"Manufacturers":["seeed","dfrobot","sparkfun","adafruit","generic"],"Kits":["gsk"],"Image":"mic.jpg","Examples":{"Java":["MicrophoneSample.java"],"Python":["mic.py"],"Node.js":["mic.js"],"C++":["mic.cxx"]},"Urls":{"Product Pages":["http://www.seeedstudio.com/wiki/Grove_-_Sound_Sensor"],"Schematics":["https://github.com/SeeedDocument/Grove_Sound_Sensor/raw/master/res/Grove%20-%20Sound%20Sensor%20v1.6%20Schematic.pdf"]}}}},{"Library":"micsv89","Description":"MICS-VZ89 environmental sensor library","Sensor Class":{"micsv89":{"Name":"API for the MICS-VZ89 Gas Sensor","Description":"This is the UPM Module for the SGX Sensortech MICS-VZ-89. The MiCS-VZ-86/89 combines state-of-the-art MOS sensor technology with intelligent detection algorithms to monitor VOCs and CO2 equivalent variations in confined spaces. This library only supports the i2c variants of this sensor.","Aliases":["micsv89","MICS-VZ-89TE","MICS-VZ-89TE Indoor Air Quality Sensor"],"Categories":["gaseous"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["SGX"],"Image":"micsv89.jpg","Examples":{"Node.js":["micsv89.js"],"C++":["micsv89.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Warm-up Time":{"unit":"minute","time":15}},"Urls":{"Product Pages":["https://sgx.cdistore.com/ProductDetail/MICSVZ89TE-SGX-Sensortech-Limited/598202/"],"Datasheets":["https://sgx.cdistore.com/datasheets/e2v/MiCS-VZ-89TE_V1.0.pdf"]}}}},{"Library":"mlx90614","Description":"MLX90614 Temperature Sensor library","Sensor Class":{"mlx90614":{"Name":"API for the Melexis MLX90614 Temperature Sensor","Description":"This is the UPM Module for the Melexis mlx90614 temperature sensor. The MLX90614 is an infrared thermometer for non-contact temperature measurements. Both the IR sensitive thermopile detector chip and the signal conditioning ASIC are integrated in the same TO-39 can. Integrated into the MLX90614 are a low noise amplifier, 17-bit ADC and powerful DSP unit thus achieving high accuracy and resolution of the thermometer.","Aliases":["mlx90614","Digital plug & play infrared thermometer in a TO-can"],"Categories":["temperature"],"Connections":["i2c"],"Project Type":["medical","industrial","commercial"],"Manufacturers":["Melexis"],"Image":"mlx90614.jpg","Examples":{"C++":["mlx90614.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.6,"max":5.5},"Supply Current":{"unit":"mA","min":1.3,"max":2},"Operating Temperature":{"unit":"°C","min":-40,"max":125},"Effective Range":{"unit":"°C","min":-70,"max":380},"Accuracy":{"Between 0 and 50 °C":{"unit":"°C","accuracy":0.5}},"Resolution":{"unit":"°C","resolution":"0.02"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.melexis.com/en/product/MLX90614/Digital-Plug-Play-Infrared-Thermometer-TO-Can"],"Datasheets":["https://www.melexis.com/-/media/files/documents/datasheets/mlx90614-datasheet-melexis.pdf"]}}}},{"Library":"mma7361","Description":"UPM API for the DFRobot MMA7361 Analog Accelerometer","Sensor Class":{"mma7361":{"Name":"API for the DFRobot MMA7361 Analog Accelerometer","Description":"This is the UPM Module for the DFRobot mma7361 analog accelerometer. This triaxial accelerometer has variable sensitivity, and offers an easy to read analog interface. This library was tested with the DFRobot MMA7361 Analog Accelerometer.","Aliases":["mma7361","Triple Axis Accelerometer MMA7361","DFR0143"],"Categories":["accelerometer"],"Connections":["analog","gpio"],"Project Type":["prototyping"],"Manufacturers":["DFRobot"],"Image":"mma7361.jpg","Examples":{"Java":["MMA7361_Example.java"],"Python":["mma7361.py"],"Node.js":["mma7361.js"],"C++":["mma7361.cxx"],"C":["mma7361.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":8},"Supply Current":{"Measurement Mode":{"unit":"uA","typ":500},"Standby Mode":{"unit":"uA","typ":3}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"mV/g","sensativity":800},"Sensitivity":{"unit":"g","min":1.5,"max":6}},"Platforms":{"Intel Edison":{"Notes":["Might DFRobot IO/Sensor expansion board."]},"Arduino 101":{"Notes":["Might DFRobot IO/Sensor expansion board."]}},"Urls":{"Product Pages":["https://www.dfrobot.com/product-507.html#.V7YEj99ytNJ"],"Datasheets":["https://www.dfrobot.com/wiki/index.php/Triple_Axis_Accelerometer_MMA7361_SKU:DFR0143","http://www.nxp.com/docs/en/data-sheet/MMA7361L.pdf"]}}}},{"Library":"mma7455","Description":"NXP MMA7455 Accelerometer library","Sensor Class":{"mma7455":{"Name":"API for the NXP MMA7455 Accelerometer","Description":"This is the UPM Module for the NXP MMA7455 Accelerometer. The MMA7455L 3-Axis Digital Output Accelerometer is a low power, micro machined sensor capable of measuring acceleration along its X, Y, and Z axes. It offers several convenient integrated features including an analog to digital converter (ADC), digital low-pass filter, and selectable sensitivity ranges of ±2g, ±4g, or ±8g. This device can be easily configured to detect quick motion pulses as single taps, double taps, and 0g (free fall) conditions on any or all axes and provides configurable interrupt pins (INT1 and INT2) for each type of event.","Aliases":["mma7455","MMA7455 3-Axis Accelerometer Module"],"Categories":["accelerometer"],"Connections":["i2c","spi"],"Project Type":["prototyping","robotics"],"Manufacturers":["NXP","Freescale"],"Image":"mma7455.jpg","Examples":{"Java":["MMA7455Sample.java"],"C++":["mma7455.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Sensitivity":{"unit":"g","min":2,"max":10},"Supply Current":{"Standby Mode":{"unit":"uA","typ":26},"Full Operation":{"unit":"mA","typ":"<3"}}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.parallax.com/product/28526"],"Datasheets":["https://www.parallax.com/sites/default/files/downloads/28526-Freescale-MMA7455L-Device-Documentation.pdf"]}}}},{"Library":"mma7660","Description":"MMA7660 I2C 3-Axis Digital Accelerometer library","Sensor Class":{"mma7660":{"Name":" API for the Seeed/NXP MMA7660 I2C 3-Axis Digital Accelerometer","Description":"This is the UPM Module for the Seeed/NXP MMA7660 i2c 3-axis digital accelerometer. This device supports a variety of capabilities, including the generation of interrupts for various conditions, tilt and basic gesture detection, and X/Y/Z-axis measurements of g-forces being applied","Aliases":["mma7660","Grove - 3-Axis Digital Accelerometer(±1.5g)"],"Categories":["accelerometer"],"Connections":["i2c","gpio"],"Project Type":["prototyping","robotics"],"Manufacturers":["Seeed","NXP"],"Image":"mma7660.jpg","Examples":{"Java":["MMA7660Sample.java"],"Python":["mma7660.py"],"Node.js":["mma7660.js"],"C++":["mma7660.cxx"],"C":["mma7660.c"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5.5},"Supply Current":{"unit":"uA","min":0.4,"max":47},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Sensitivity":{"unit":"LSB/g","sensitivity":"21"}},"Platforms":{"Intel Edison":{"Notes":["Might Grove breakout shield"]},"Arduino 101":{"Notes":["Might Grove breakout shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-3-Axis-Digital-Accelerometer(%C2%B11.5g)-p-765.html"],"Datasheets":["http://wiki.seeed.cc/Grove-3-Axis_Digital_Accelerometer-1.5g/"]}}}},{"Library":"mma8x5x","Description":"MMA8X5X Family Three-Axis Accelerometer Library","Sensor Class":{"mma8451":{"Name":"API for the Adafruit/Freescale MMA8451 Three-Axis Accelerometer","Description":"This is the UPM Module for the Adafruit/Freescale mma8451 three-axis accelerometer. This simple accelerometer and breakout board are a great starting point for working with accelerometers in general. This is the most percise of the mma8x5x series, offering a 14-bit analog to digital converter onboard. The Adafruit breakout board makes it easy to mount to breadboard or perfboard.","Aliases":["mma8451","mma8x5x","Adafruit Triple-Axis Accelerometer - ±2/4/8g"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Freescale","Adafruit"],"Image":"mma8x5x.jpg","Examples":{"Python":["mma8x5x.py"],"C++":["mma8x5x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"uA","min":6,"max":165},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"unit":"g","min":2,"max":8},"Sensitivity":{"unit":"LSB/g","min":1024,"max":4096}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/2019"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/MMA8451Q-1.pdf"]}},"mma8452q":{"Name":"API for the Sparkfun/Freescale MMA8451Q Three-Axis Accelerometer","Description":"This is the UPM Module for the Sparkfun/Freescale mma8452 three-axis accelerometer. This breakout board makes it easy to use the tiny MMA8452Q accelerometer in your project. The MMA8452Q is a smart low-power, three-axis, capacitive MEMS accelerometer with 12 bits of resolution. The MMA8452Q has user-selectable full scales of ±2g/±4g/±8g.","Aliases":["mma8452q","mma8x5x","SparkFun Triple Axis Accelerometer Breakout - MMA8452Q"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Freescale","Sparkfun"],"Image":"mma8x5x.jpg","Examples":{"Python":["mma8x5x.py"],"C++":["mma8x5x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.95,"max":3.6},"Supply Current":{"unit":"uA","min":6,"max":165},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"unit":"g","min":2,"max":8},"Sensitivity":{"unit":"LSB/g","min":256,"max":1024}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/12756"],"Datasheets":["https://cdn.sparkfun.com/datasheets/Sensors/Accelerometers/MMA8452Q-rev8.1.pdf"]}},"mma8453q":{"Name":"API for the NXP MMA8453Q Three-Axis Accelerometer","Description":"This is the UPM Module for the NXP mma8453q three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of ±2g/±4g/±8g.","Aliases":["mma8453q","mma8x5x","MMA8453Q: ±2g/±4g/±8g, Low g, 10-bit Digital Accelerometer"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["NXP"],"Image":"mma8x5x.jpg","Examples":{"Python":["mma8x5x.py"],"C++":["mma8x5x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.95,"max":3.6},"Supply Current":{"unit":"uA","min":6,"max":165},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"unit":"g","min":2,"max":8},"Sensitivity":{"unit":"LSB/g","min":64,"max":256}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-10-bit-digital-accelerometer:MMA8453Q"],"Datasheets":["http://www.nxp.com/docs/en/data-sheet/MMA8453Q.pdf"]}},"mma8652fc":{"Name":"API for the NXP MMA8652FC Three-Axis Accelerometer","Description":"This is the UPM Module for the NXP mma8652fc three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of ±2g/±4g/±8g.","Aliases":["mma8652fc","mma8x5x","MMA8652FC: ±2g/±4g/±8g, Low g, 12-Bit Digital Accelerometer"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["NXP"],"Image":"mma8x5x.jpg","Examples":{"Python":["mma8x5x.py"],"C++":["mma8x5x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.95,"max":3.6},"Supply Current":{"unit":"uA","min":6,"max":165},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"unit":"g","min":2,"max":8},"Sensitivity":{"unit":"LSB/g","min":256,"max":1024}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-12-bit-digital-accelerometer:MMA8652FC"],"Datasheets":["http://www.nxp.com/docs/en/data-sheet/MMA8652FC.pdf"]}},"mma8653fc":{"Name":"API for the NXP MMA8653FC Three-Axis Accelerometer","Description":"This is the UPM Module for the NXP mma8653fc three-axis accelerometer. This accelerometer is packed with embedded functions with flexible user-programmable options configurable to two interrupt pins. Embedded interrupt functions allow for overall power savings relieving the host processor from continuously polling data. The MMA8453Q has user-selectable full scales of ±2g/±4g/±8g.","Aliases":["mma8653fc","mma8x5x","MMA8653FC: ±2g/±4g/±8g, Low g, 12-Bit Digital Accelerometer"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["NXP"],"Image":"mma8x5x.jpg","Examples":{"Python":["mma8x5x.py"],"C++":["mma8x5x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.95,"max":3.6},"Supply Current":{"unit":"uA","min":6,"max":165},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"unit":"g","min":2,"max":8},"Sensitivity":{"unit":"LSB/g","min":64,"max":256}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://www.nxp.com/products/sensors/accelerometers/3-axis-accelerometers/2g-4g-8g-low-g-10-bit-digital-accelerometer:MMA8653FC"],"Datasheets":["http://www.nxp.com/docs/en/data-sheet/MMA8653FC.pdf"]}}}},{"Library":"mmc35240","Description":"Memsic MMC35240 Tri-axis Magnetic Sensor Library","Sensor Class":{"MMC35240":{"Name":"Memsic MMC35240 Tri-axis Magnetic Sensor API","Description":"This is the UPM Module for the Memsic MMC35240 Tri-axis Magnetic Sensor. Fully integrated 3-axis magnetic sensor and electronic circuits requiring fewer external components.","Aliases":["mmc35240","MMC3530KJ"],"Categories":["compass"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["Memsic"],"Image":"mmc35240.jpg","Examples":{"C++":["mmc35240.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.62,"max":1.98},"Supply Current":{"unit":"uA","typ":"160"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Sensitivity":{"unit":"mG/LSB","min":"1","max":"4"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.memsic.com/magnetic-sensors/MMC3530KJ"],"Datasheets":["https://www.memsic.com/magnetic-sensors/MMC3530KJ"]}}}},{"Library":"moisture","Description":"Moisture Sensor library","Sensor Class":{"moisture":{"Name":"API for the Grove Moisture Sensor ","Description":"This is the UPM Module for the Grove moisture sensor. This sensor can be used to detect the moisture content of soil or whether there is water around the sensor. As the moisture content increases, so does the value that is read. Note: this sensor is not designed to be left in soil nor to be used outdoors.","Aliases":["Grove Moisture Sensor"],"Categories":["liquid"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["eak","hak"],"Image":"moisture.jpg","Examples":{"Java":["MoistureSample.java"],"Python":["moisture.py"],"Node.js":["moisture.js"],"C++":["moisture.cxx"],"C":["moisture.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Supply Current":{"unit":"mA","min":0,"max":35}},"Platforms":{"Intel Edison":{"Notes":["Might need the Grove base shield"]},"Arduino 101":{"Notes":["Might need the Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Moisture-Sensor-p-955.html"],"Datasheets":["http://wiki.seeed.cc/Grove-Moisture_Sensor/"]}}}},{"Library":"mpl3115a2","Description":"NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor library","Sensor Class":{"mpl3115a2":{"Name":"NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor","Description":"This is the UPM Module for the NXP/Adafruit MPL3115A2 Atmospheric Pressure Sensor. This sensor is a compact absolute pressure sensor, with a wide operating range and high operating accuracy, offering a 24-bit ADC onboard. It also offers internal compensation, and a fast i2c interface.","Aliases":["mpl3115a2","MPL3115A2 - I2C Barometric Pressure/Altitude/Temperature Sensor"],"Categories":["pressure"],"Connections":["i2c"],"Project Type":["medical","industrial","commercial"],"Manufacturers":["NXP","Adafruit"],"Image":"mpl3115a2.jpg","Examples":{"Java":["MPL3115A2Sample.java"],"C++":["mpl3115a2.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5.5},"Supply Current":{"unit":"uA","min":"8.5","max":"265"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Range":{"Calibrated Range":{"unit":"kPa","min":50,"max":110},"Operational Range":{"unit":"kPa","min":20,"max":110}},"Pressure Accuracy":{"unit":"kPa","lower":"-0.4","upper":"0.4"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1893"],"Datasheets":["http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf"]}}}},{"Library":"mpr121","Description":"Seeed/FreeScale MPR121 Touch Sensor library","Sensor Class":{"mpr121":{"Name":"Seeed/FreeScale MPR121 Touch Sensor","Description":"This is the UPM Module for the Seeed/FreeScale MPR121 Touch Sensor. The MPR121 is a capacitive touch sensor controller,features internal intelligence, include an hardware configurable I2C address, an expended filtering system with debounce, and completely independent electrodes with auto-configuration built in. Note: Each touch sensor comes with 4 \"feelers\" that act as capacitive pads for touch detection.","Aliases":["mpr121","Grove - I2C Touch Sensor"],"Categories":["touch"],"Connections":["i2c"],"Project Type":["prototyping"],"Manufacturers":["Seeed","FreeScale"],"Kits":["tsk"],"Image":"mpr121.jpg","Examples":{"Java":["MPR121Sample.java"],"Python":["mpr121.py"],"Node.js":["mpr121.js"],"C++":["mpr121.cxx"],"C":["mpr121.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"uA","min":"2","max":"29"},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need the Grove base shield"]},"Arduino 101":{"Notes":["Might need the Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-I2C-Touch-Sensor-p-840.html"],"Datasheets":["https://www.sparkfun.com/datasheets/Components/MPR121.pdf"]}}}},{"Library":"mpu9150","Description":"InvenSense/Seeed MPU9150 accelerometer library","Sensor Class":{"mpu9150":{"Name":"InvenSense/Seeed MPU9150 accelerometer","Description":"This is the UPM Module for the InvenSense/Seeed MPU9150 accelerometer. The MPU-9150 is the world's first integrated 9-axis motion tracking device designed for the low power, low cost, and high performance requirements of consumer electronics equipment including smartphones, tablets and wearable sensors. MPU-9150 features three 16-bit ADC for digitizing the gyroscope outputs and three 16-bit ADCs for digitizing the accelerometer outputs and three 13-bit ADCs for digitizing the magnetometer outputs","Aliases":["mpu9150","Grove - IMU 9DOF v1.0"],"Categories":["accelerometer","gyroscope","compass"],"Connections":["i2c","gpio"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["InvenSense","Seeed"],"Image":"mpu9150.jpg","Examples":{"Java":["MPU9150Sample.java"],"Python":["mpu9150.py"],"Node.js":["mpu9150.js"],"C++":["mpu9150-ak8975.cxx.cxx","mpu9150-mpu60x0.cxx","mpu9150-mpu9250.cxx","mpu9150.cxx"]},"Specifications":{"Vsource":{"unit":"V","typ":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Communication Speed":{"unit":"kHz","typ":400},"Gyroscope Range":{"unit":"°/sec","min":"-/+250","max":"-/+2000"},"Accelerometer Range":{"unit":"g","min":"-/+2","max":"-/+16"}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["http://wiki.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v1.0"],"Datasheets":["http://wiki.seeedstudio.com/images/5/51/MPU-9150.pdf"]}}}},{"Library":"mq303a","Description":"Seeed MQ303A Alcohol Sensor library","Sensor Class":{"mq303a":{"Name":"API for the Seeed MQ303A Alcohol Sensor","Description":"This is the UPM Module for the Seeed MQ303A Alcohol Sensor. It has good sensitivity and fast response to alcohol. It is suitable for making Breathalyzer. This Grove implements all the necessary circuitry for MQ303A like power conditioning and heater power supply. This sensor outputs a voltage inversely proportional to the alcohol concentration in air.","Aliases":["mq303a","Grove - Alcohol Sensor"],"Categories":["gaseous"],"Connections":["analog"],"Project Type":["medical","prototyping"],"Manufacturers":["Seeed"],"Kits":["tsk"],"Image":"mq303a.jpg","Examples":{"Java":["MQ303ASample.java"],"Python":["mq303a.py"],"Node.js":["mq303a.js"],"C++":["mq303a.cxx"],"C":["mq303a.c"]},"Specifications":{"Vsource":{"unit":"V","typ":5},"Supply Current":{"unit":"mA","min":100,"max":140},"Effective Range":{"unit":"ppm","min":20,"max":1000},"Warm-up Time":{"unit":"hours","min":2,"recommended":48},"Operating Temperature":{"unit":"°C","min":18,"max":22},"Operating Humidity":{"unit":"RH","min":"60%","max":"70%"}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Alcohol-Sensor-p-764.html","http://wiki.seeed.cc/Grove-Alcohol_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Alcohol_Sensor/master/res/MQ303A.pdf"]}}}},{"Library":"ms5611","Description":"Amsys ms5611 Barometric Pressure Sensor library","Sensor Class":{"ms5611":{"Name":"API for Amsys MS5611 Barometric Pressure Sensor library","Description":"This is the UPM Module for the Amsys ms5611 barometric pressure sensor. The MS5611 is a new generation of high resolution altimeter sensors from MEAS Switzerland with SPI and I2C bus interface. This module implements I2C only.","Aliases":["ms5611","MS5611 GY-63 Atmospheric Pressure Sensor Module IIC/SPI Communication"],"Categories":["pressure","temperature"],"Connections":["i2c"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["Amsys"],"Image":"ms5611.jpg","Examples":{"Node.js":["ms5611.js"],"C++":["ms5611.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.8,"max":3.6},"Supply Current":{"unit":"uA","min":"0.9","max":"12.5"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Pressure Sensor":{"Effective Pressure Range":{"unit":"mbar","min":10,"max":1200},"Resolution":{"unit":"mbar","min":"0.012","max":"0.065"},"Accuracy":{"unit":"mbar","min":"-1.5","max":"1.5"},"Response Time":{"unit":"ms","min":"0.5","max":"8.22"}},"Temperature Sensor":{"Effective Temperature Range":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"°C","typ":"<0.01"},"Accuracy":{"unit":"°C","min":-0.8,"max":0.8}}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.banggood.com/MS5611-GY-63-Atmospheric-Pressure-Sensor-Module-IICSPI-Communication-p-965980.html","http://www.amsys.info/products/ms5611.htm"],"Datasheets":["http://www.amsys.info/sheets/amsys.en.ms5611_01ba03.pdf"]}}}},{"Library":"ms5803","Description":"Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor Library","Sensor Class":{"ms5803":{"Name":"API for the Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor","Description":"This is the UPM Module for the Measurement Specialties/Sparkfun MS5803 Pressure and Temperature sensor. The MS5803-14BA is a new generation of high resolution pressure sensors with SPI and I2C bus interface. It is optimized for depth measurement systems with a water depth resolution of 1cm and below. The sensor module includes a high linear pressure sensor and an ultra low power 24 bit delta-sigma ADC with internal factory calibrated coefficients. It provides a precise digital 24 bit pressure and temperature value and different operation modes that allow the user to optimize for conversion speed and current consumption. A high resolution temperature output allows the implementation of a depth measurement systems and thermometer function without any additional sensor.","Aliases":["ms5803","SparkFun Pressure Sensor Breakout - MS5803-14BA"],"Categories":["pressure","temperature"],"Connections":["i2c","spi"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["Measurement Specialties","SparkFun"],"Image":"abp.jpg","Examples":{"Java":["MS5803_Example.java"],"Python":["ms5803.py"],"Node.js":["ms5803.js"],"C++":["ms5803.cxx"],"C":["ms5803.c"]},"Specifications":{"Vsource":{"unit":"V","min":1.8,"max":3.6},"Supply Current":{"unit":"uA","min":"0.9","max":"12.5"},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Pressure Sensor":{"Effective Pressure Range":{"unit":"bar","min":0,"max":14},"Resolution":{"unit":"mbar","min":"0.2","max":"1"},"Accuracy":{"unit":"mbar","min":-40,"max":40},"Response Time":{"unit":"ms","min":0.5,"max":8.22}},"Temperature Sensor":{"Effective Temperature Range":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"°C","typ":"<0.01"},"Accuracy":{"unit":"°C","min":-0.8,"max":0.8}}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/12909"],"Datasheets":["https://cdn.sparkfun.com/datasheets/Sensors/Weather/ms5803_14ba.pdf"]}}}},{"Library":"my9221","Description":"My-semi MY9221 12-channel LED driver Library","Sensor Class":{"grovecircularled":{"Name":"API for the Grove Circular LED module/My-semi MY9221 12-channel LED driver","Description":"This is the UPM Module for the Grove Circular LED module/My-semi MY9221 12-channel LED driver. This is a circular LED ring based on the MY9221 chip. It is often used with a rotary encoder and has 24 controllable LEDs.","Aliases":["my9221","Grove - Circular LED","MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],"Categories":["display"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed","My-semi"],"Image":"grovecircularled.jpg","Examples":{"Python":["grovecircularled.py"],"Node.js":["grovecircularled.js"],"C++":["my9221-grovecircularled.cxx.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.5,"max":5.5},"Supply Current":{"unit":"mA","typ":"5.5 per LED"},"LEDs":{"unit":"LED","leds":24},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["http://wiki.seeedstudio.com/wiki/Grove_-_Circular_LED"],"Datasheets":["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]}},"groveledbar":{"Name":"API for the Grove - LED Bar/My-semi MY9221 12-channel LED driver","Description":"This is the UPM Module for the Grove - LED Bar/My-semi MY9221 12-channel LED driver. This is a 10-segment LED bar, with 8 green segments, 1 yellow segment, and one red segment.  They can be daisy chained together so that this module can control multiple LED bars.","Aliases":["my9221","Grove - LED Bar","MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],"Categories":["display"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed","My-semi"],"Kits":["eak"],"Image":"my9221.jpg","Examples":{"Java":["GroveLEDBar.java"],"Python":["groveledbar.py"],"Node.js":["groveledbar.js"],"C++":["my9221-groveledbar.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5.5},"Supply Current":{"unit":"mA","typ":"5.5 per LED"},"LEDs":{"unit":"LED","leds":10},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduinon 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-LED-Bar-p-1178.html","http://wiki.seeed.cc/Grove-LED_Bar/"],"Datasheets":["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]}},"my9221 ":{"Name":"API for the My-semi MY9221 12-channel LED driver","Description":"This is the UPM Module for the My-semi MY9221 12-channel LED driver. This is the base for several grove LED modules, allowing finite control of individual LEDs","Aliases":["my9221","MY9221 12-Channel LED Driver With Grayscale Adaptive Pulse Density Modulation Control"],"Categories":["display"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["My-semi"],"Kits":["eak"],"Image":"my9221.jpg","Examples":{"C++":["my9221-grovecircularled.cxx","my9221-groveledbar.cxx"],"C":["my9221.c"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5.5},"Supply Current":{"unit":"mA","typ":"5.5 per LED"},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduinon 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-LED-Bar-p-1178.html","http://wiki.seeed.cc/Grove-LED_Bar/"],"Datasheets":["http://www.my-semi.com.tw/file/MY9221_BF_3.0.pdf"]}}}},{"Library":"nlgpio16","Description":"Numato NLGPIO16 16 Channel USB GPIO Module Library","Sensor Class":{"nlgpio16":{"Name":"API for the Numato NLGPIO16 16 channel USB GPIO Module","Description":"This is the UPM Module for the Numato NLGPIO16 16 channel USB GPIO Module. The NLGPIO16 is a USB adapter providing access to 16 GPIO's, 7 of which can be used as analog inputs.  The GPIO's are 3.3v only.  An external power supply can be connected to provide more current if the need arises. It is recommended to use a series resistor with the GPIO/ADC pins when interfacing with other circuits. In output mode, GPIOs can source up to 8mA (gpio8-gpio15). So no additional circuitry is needed to drive regular LEDs. A 470 Ohms series resistor is recommended for current limiting when connecting an LED to a GPIO. In contrast to GPIOs, analog inputs can read voltages at any level between 0 to 3.3V volts. It is recommended to use a series resistor to protect the input from stray voltages and spikes. The internal Analog to Digital converter supports 10 bits resolution which is adequate for most applications.","Aliases":["nlgpio16","Numato 16 Channel USB GPIO Module With Analog Inputs"],"Categories":["other"],"Connections":["uart"],"Project Type":["prototyping"],"Manufacturers":["Numato Lab"],"Image":"nlgpio16.jpg","Examples":{"Python":["nlgpio16.py"],"Node.js":["nlgpio16.js"],"C++":["nlgpio16.cxx"]},"Specifications":{"Vsource":{"unit":"V","usb":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Analog Inputs":{"unit":"inputs","inputs":7},"TTL Inputs":{"unit":"TTL 3.3V inputs","inputs":16},"ADC Resolution":{"unit":"bit","bits":10}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://numato.com/16-channel-usb-gpio-module-with-analog-inputs/"],"Datasheets":["https://docs.numato.com/doc/16-channel-usb-gpio-module-with-analog-inputs/"]}}}},{"Library":"nmea_gps","Description":"UPM C++ API for a generic GPS serial device reporting NMEA data","Sensor Class":{"nmea_gps":{"Name":"API for the NMEA GPS Module","Description":"This is the UPM Module for a generic GPS serial device reporting NMEA data. This driver was tested with a number of GPS devices that emit NMEA data via a serial interface of some sort (typically a UART). The I2C capablity was tested with a UBLOX LEA-6H based GPS shield from DFRobot.  Currently, the I2C capability is only supported for UBLOX devices (or compatibles) that conform to the specifications outlined in the u-blox6 Receiver Description Protocol Specification, Chapter 4, DDC Port.","Aliases":["VK2828u7","ublox","LEA-6H"],"Categories":["gps"],"Connections":["uart","gpio"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["DFRobot","Seeed"],"Image":"nmea_gps.jpg","Examples":{"Java":["NMEAGPS_Example.java","NMEAGPS_I2C_Example.java"],"Python":["nmea_gps.py","nmea_gps_i2c.py"],"Node.js":["nmea_gps.js","nmea_gps_i2c.js"],"C++":["nmea_gps.cxx","nmea_gps-i2c.cxx"],"C":["nmea_gps.c","nmea_gps-i2c.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors","Might need Grove base shield","Might need DFRobot breakout board"]},"Arduino 101":{"Notes":["Might need pull up resistors","Might need Grove base shield","Might need DFRobot breakout board"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/grove-gps-p-959.html","https://www.dfrobot.com/product-481.html"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-GPS/master/res/E-1612-UB_Datasheets_Sheet.pdf"]}}}},{"Library":"nrf24l01","Description":"Nordic Semiconductor NRF24L01 Transceiver library","Sensor Class":{"nrf24l01":{"Name":"API for the Nordic Semiconductor NRF24L01 Transceiver Module","Description":"This is the UPM Module for the Nordic Semiconductor NRF24L01 Transceiver Module. This transceiver IC operates in the 2.4GHz band and has many new features! Take all the coolness of the nRF2401A and add some extra pipelines, buffers, and an auto-retransmit feature.","Aliases":["nrf24l01","SparkFun Transceiver Breakout - nRF24L01+"],"Categories":["wifi"],"Connections":["spi"],"Project Type":["prototyping","commercial"],"Manufacturers":["Nordic Semiconductor","SparkFun"],"Image":"nrf24l01.jpg","Examples":{"Java":["NRF24L01_receiverSample.java","NRF24L01_transmitterSample.java"],"C++":["nrf24l01-broadcast.cxx","nrf24l01-receiver.cxx","nrf24l01-transmitter.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":7},"Supply Current":{"Idle Mode Supply":{"unit":"uA","min":0.9,"max":320},"Transmit Mode Supply":{"unit":"mA","min":0.12,"max":11.3},"Recieve Mode Supply":{"unit":"mA","min":8.4,"max":12.3}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Operating Frequency":{"unit":"MHz","min":2400,"max":2525},"Data Rate":{"unit":"kbps","min":250,"max":2000}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/691"],"Datasheets":["file:///D:/Downloads/nRF24L01_Product_Specification_v2_0.pdf"]}}}},{"Library":"nrf8001","Description":"Nordic Semiconductor NRF8001 Bluetooth Low Energy library","Sensor Class":{"nrf8001":{"Name":"API for the Nordic Semiconductor NRF8001 Bluetooth Low Energy Module","Description":"This is the UPM Module for the Nordic Semiconductor NRF8001 Bluetooth Low Energy Module. These files define the NRF8001 interface for lib-nrf8001. Interaction with this device is done through the ACI routines included with the library. You can use the nRF UART app in Apple* App Store and Google* Play* on Samsung* Galaxy S*4 running Android* 4.3 to interact with a microcontroller running the 'hello world' example.","Aliases":["nrf8001","Bluefruit LE - Bluetooth Low Energy (BLE 4.0) - nRF8001 Breakout - v1.0"],"Categories":["wifi"],"Connections":["spi","gpio","analog"],"Project Type":["prototyping"],"Manufacturers":["Nordic Semiconductor","Adafruit"],"Image":"nrf8001.jpg","Examples":{"C++":["nrf8001-broadcast.cxx","nrf8001-helloworld.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.9,"max":3.6},"Supply Current":{"unit":"uA","min":2,"max":14000},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Bluetooth Version":{"unit":"version number","version":"BLE V4.0"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1697","http://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF8001"],"Datasheets":["https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/introduction","http://www.nordicsemi.com/eng/nordic/download_resource/17534/16/64902106/2981"]}}}},{"Library":"nunchuck","Description":"Wii Nunchuk library","Sensor Class":{"nunchuck":{"Name":"API for the Wii* Nunchuk controller","Description":"UPM module for the Wii Nunchuk controller. This module was tested with Wii Nunchuck connected to I2C via a Grove Wii Nunchuck adapter. See http://wiibrew.org/wiki/Wiimote/Extension_Controllers and http://wiibrew.org/wiki/Wiimote/Extension_Controllers/Nunchuck for more details on the controller and its protocol. A warning for the Grove Wii Nunchuk adapter: it has 2 traces on one side, and 3 traces on the other. Do not match these up with the Nunchuk connector's traces. The connector's 'groove' should be on the same side as the Grove interface socket on the adapter.","Aliases":["nunchuck","Wii nunchuck","Grove - Nunchuck"],"Categories":["accelerometer"],"Connections":["i2c"],"Project Type":["prototyping"],"Manufacturers":["generic"],"Kits":["robok"],"Image":"nunchuck.jpg","Examples":{"Java":["NUNCHUCKSample.java"],"Python":["nunchuck.py"],"Node.js":["nunchuck.js"],"C++":["nunchuck.cxx"],"C":["nunchuck.c"]},"Specifications":{"Vsource":{"unit":"V","typ":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Nunchuck-p-1474.html","http://wiibrew.org/wiki/Wiimote/Extension_Controllers","http://wiibrew.org/wiki/Wiimote/Extension_Controllers/Nunchuck"],"Datasheets":["http://wiki.seeed.cc/Grove-NunChuck/"]}}}},{"Library":"otp538u","Description":"Oriental System Technology OTP538U IR Temperature Sensor library","Sensor Class":{"otp538u":{"Name":"API for the Oriental System Technology OTP538U IR Temperature Sensor","Description":"This is the UPM Module for the Oriental System Technology OTP538U IR Temperature Sensor. This Grove-Infrared temperature sensor is a non-contact temperature measure model.The sensor is composed of 116 elements of thermocouple in series on a floating micro-membrane having an active diameter of 545μm and with blacken surface to absorb the incident thermal infrared radiation, which induces a voltage response at output terminals.","Aliases":["otp538u","Grove - Infrared Temperature Sensor"],"Categories":["light","temperature"],"Connections":["analog"],"Project Type":["prototyping","commercial"],"Manufacturers":["Oriental System Technology","Seeed"],"Kits":["hak"],"Image":"otp538u.jpg","Examples":{"Java":["OTP538USample.java"],"Python":["otp538u.py"],"Node.js":["otp538u.js"],"C++":["otp538u.cxx"],"C":["otp538u.c"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5},"Supply Current":{"unit":"uA","min":160,"max":200},"Operating Temperature":{"unit":"°C","min":-10,"max":80},"Effective Temperature Range":{"unit":"°C","min":-10,"max":100},"Accuracy":{"unit":"°C","min":-2,"max":2},"Holding Time":{"unit":"s","time":2}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield","Will NOT work on 3.3V"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Infrared-Temperature-Sensor-p-1058.html","http://wiki.seeed.cc/Grove-Infrared_Temperature_Sensor/"],"Datasheets":["http://wiki.seeedstudio.com/images/f/f2/OTP-538Udatasheet.zip"]}}}},{"Library":"ozw","Description":"UPM OpenZWave library","Sensor Class":{"ozw":{"Name":"API for the OpenZWave library","Description":"This module implements a singleton wrapper around the OpenZWave library. OpenZWave must be compiled and installed on your machine in order to use this library. This module was developed with OpenZWave 1.3/1.4, and an Aeon Z-Stick Gen5 configured as a Primary Controller. It provides the ability to query and set various values that can be used to control ZWave devices. It does not concern itself with configuration of devices. It is assumed that you have already setup your ZWave network using a tool like the OpenZWave control panel, and have already configured your devices as appropriate. To avoid exposing some of the internals of OpenZWave, devices (nodes) and their values, are accessed via a nodeId and a value index number. The ozwdump example will run dumpNodes() which will list the currently connected devices and the values that are available to them, along with an index number for that value. It is through these values (nodeId and index) that you can query and set device values at a low level. In addition to querying values from a device (such as state (on/off), or temperature, etc), methods are provided to allow you to control these devices to the extent they allow, for example, using a ZWave connected switch to turn on a lamp. Access to this class by OZW drivers is handled by the ozwInterface class. It is that class that drivers use for access to ozw, and therefore the Z-Wave network. This class is not intended to be used directly by end users. When writing an OZW driver, the ozwInterface class should be used (inherited) by your driver, and your driver should wrap and expose only those methods needed by the user. Take a look at some of the drivers (like aeotecss6) to see how this works.","Aliases":["ozw"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["commercial"],"Manufacturers":["Aeon Labs"],"Image":"dsb09104.jpg","Examples":{"Java":["AeotecDSB09104_Example.java","AeotecDW2E_Example.java","AeotecSDG2_Example.java","AeotecSS6_Example.java"],"Python":["aeotecdsb09104.py","aeotecdw2e.py","aeotecsdg2.py","aeotecss6.py"],"Node.js":["aeotecdsb09104.js","aeotecdw2e.js","aeotecsdg2.js","aeotecss6.js"],"C++":["ozw-aeotecdsb09104.cxx","ozw-aeotecdw2e.cxx","ozw-aeotecsdg2.cxx","ozw-aeotecss6.cxx","ozw-ozwdump.cxx","ozw-tzemt400.cxx"]},"Urls":{"Product Pages":["http://www.openzwave.com/"]}},"dsb09104":{"Name":"API for Aeon Labs Aeotec Home Energy Meter Gen 1","Description":"This is the UPM Module for the Aeon Labs Aeotec Home Energy Meter Gen 1. This module allows for monitoring certain elements of an Aeotec Home Energy Meter Gen 1.","Aliases":["dsb09104"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["commercial"],"Manufacturers":["Aeon Labs"],"Image":"dsb09104.jpg","Examples":{"Java":["AeotecDSB09104_Example.java"],"Python":["aeotecdsb09104.py"],"Node.js":["aeotecdsb09104.js"],"C++":["ozw-aeotecdsb09104.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":220,"max":400},"Supply Current":{"unit":"A","max":200}},"Urls":{"Product Pages":["https://aeotec.freshdesk.com/support/solutions/articles/6000161943-home-energy-meter-gen5-user-guide-"]}},"DSB29":{"Name":"API for the Aeon Labs Aeotec Door/Window Sensor 2nd Edition","Description":"This is the UPM Module for the Aeon Labs Aeotec Door/Window Sensor 2nd Edition. This module allows for monitoring certain elements of an Aeotec Door/Window Sensor 2nd Edition Z-Wave device. NOTE: This is a battery powered device that spends most of it's time sleeping (sort of like a cat). This means that on initial startup, there is not enough information known about the device to reliably query anything.  Use isDeviceAvailable() to test whether the device has responded to OZW's probe request before requesting information for it.","Aliases":["dsb29"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["commercial"],"Manufacturers":["Aeon Labs"],"Image":"dsb29.jpg","Examples":{"Java":["AeotecDW2E_Example.java"],"Python":["aeotecdw2e.py"],"Node.js":["aeotecdw2e.js"],"C++":["ozw-aeotecdw2e.cxx"]},"Urls":{"Product Pages":["https://aeotec.com/z-wave-door-window-sensor"]}},"dg2":{"Name":"API for Aeon Labs Aeotec Smart Dimmer Gen 2","Description":"This is the UPM Module for the Aeon Labs Aeotec Smart Dimmer Gen 2. This module allows for controlling and monitoring certain elements of an Aeotec Smart Dimmer Gen 2.","Aliases":["dg2"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["commercial"],"Manufacturers":["Aeon Labs"],"Image":"dg2.jpg","Examples":{"Java":["AeotecSDG2_Example.java"],"Python":["aeotecsdg2.py"],"Node.js":["aeotecsdg2.js"],"C++":["ozw-aeotecsdg2.cxx"]},"Urls":{"Product Pages":["https://aeotec.freshdesk.com/support/solutions/articles/6000053613-micro-dimmer-g2-and-micro-smart-dimmer-g2-user-guide-"]}},"ss6":{"Name":"API for the Aeon Labs Aeotec Smart Switch 6","Description":"This is the UPM Module for the Aeon Labs Aeotec Smart Switch 6. This module allows for controlling and monitoring certain elements of an Aeotec Smart Switch 6.","Aliases":["ss6"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["commercial"],"Manufacturers":["Aeon Labs"],"Image":"ss6.jpg","Examples":{"Java":["AeotecSS6_Example.java"],"Python":["aeotecss6.py"],"Node.js":["aeotecss6.js"],"C++":["ozw-aeotecss6.cxx"]},"Urls":{"Product Pages":["https://aeotec.com/z-wave-plug-in-switch"]}}}},{"Library":"p9813","Description":"Shiji Lighting P9813 Chainable RGB LEDs driver library","Sensor Class":{"p9813":{"Name":"API for controlling Shiji Lighting P9813/Chainable RGB LEDs","Description":"This is the UPM Module for the Shiji Lighting P9813/Chainable RGB LEDs. This LED controller provides individually controllable LEDs through a two pin protocol","Aliases":["p9813","APA102 5050 RGB LED w/ Integrated Driver Chip"],"Categories":["LED"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Adafruit","Shiji Lighting"],"Image":"p9813.jpg","Examples":{"Java":["P9813Sample.java"],"Python":["p9813.py"],"Node.js":["p9813.js"],"C++":["p9813.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":5,"max":5.5},"Supply Current":{"unit":"mA","min":22.5,"max":26.5},"Operating Temperature":{"unit":"°C","min":-40,"max":70},"View Angle":{"unit":"°","degrees":160}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors","Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need pull up resistors","Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/2343"],"Datasheets":["https://cdn-shop.adafruit.com/product-files/2343/APA102C.pdf"]}}}},{"Library":"pca9685","Description":"NXP/Adafruit PCA9685 PWM Controller library","Sensor Class":{"pca9685":{"Name":"API for the NXP/Adafruit PCA9685 16-channel, 12-bit PWM Controller","Description":"This is the UPM Module for the NXP/Adafruit PCA9685 16-channel, 12-bit PWM Controller. You want to make a cool robot, maybe a hexapod walker, or maybe just a piece of art with a lot of moving parts. Or maybe you want to drive a lot of LEDs with precise PWM output. Then you realize that your microcontroller has a limited number of PWM outputs! What now? You could give up OR you could just get this handy PWM and Servo driver breakout.","Aliases":["PCA9685","Adafruit 16-Channel 12-bit PWM/Servo Driver - I2C interface - PCA9685"],"Categories":["led","motor"],"Connections":["i2c"],"Project Type":["prototyping","robotics"],"Manufacturers":["NXP Semiconductors","Adafruit"],"Image":"pca9685.jpg","Examples":{"Node.js":["pca9685.js"],"C++":["pca9685.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.3,"max":5.5},"Supply Current":{"unit":"mA","min":6,"max":10},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"PWM Channels":{"unit":"Channels","channels":16}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/815","https://learn.adafruit.com/16-channel-pwm-servo-driver/overview"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/PCA9685.pdf"]}}}},{"Library":"pn532","Description":"Adafruit PN532 NFC/RFID reader/writer Library","Sensor Class":{"pn532":{"Name":"API for the PN532 based Adafruit NFC/RFID reader/writer","Description":"This is the UPM Module for the PN532 based Adafruit NFC/RFID reader/writer. The PN532 is the most popular NFC chip, and is what is embedded in pretty much every phone or device that does NFC. It can pretty much do it all, such as read and write to tags and cards, communicate with phones (say for payment processing), and 'act' like a NFC tag. If you want to do any sort of embedded NFC work, this is the chip you'll want to use!","Aliases":["pn532","PN532 NFC/RFID controller breakout board - v1.6"],"Categories":["rfid"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Philips","Adafruit"],"Image":"pn532.jpg","Examples":{"Python":["pn532-writeurl.py","pn532.py"],"Node.js":["pn532-writeurl.js","pn532.js"],"C++":["pn532-writeurl.cxx","pn532.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.6,"max":3.6},"Supply Current":{"unit":"mA","min":6,"max":140},"Operating Temperature":{"unit":"°C","min":-30,"max":85}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.adafruit.com/product/364"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/pn532ds.pdf"]}}}},{"Library":"ppd42ns","Description":"Seeed/Shinyei PPD42NS Dust Sensor library","Sensor Class":{"ppd42ns":{"Name":"API for the Seeed/Shinyei PPD42NS Dust Sensor","Description":"This is the UPM Module for the Seeed/Shinyei PPD42NS Dust Sensor. This Dust Sensor gives a good indication of the air quality in an environment by measuring the dust concentration. The Particulate Matter level (PM level) in the air is measured by counting the Low Pulse Occupancy time (LPO time) in given time unit. LPO time is proportional to PM concentration. This sensor can provide reliable data for air purifier systems; it is responsive to PM of diameter 1μm.","Aliases":["ppd42ns","Grove - Dust Sensor"],"Categories":["other"],"Connections":["gpio"],"Project Type":["prototyping"],"Manufacturers":["Shinyei","Seeed"],"Kits":["eak"],"Image":"ppd42ns.jpg","Examples":{"Java":["PPD42NSSample.java"],"Python":["ppd42ns.py"],"Node.js":["ppd42ns.js"],"C++":["ppd42ns.cxx"],"C":["ppd42ns.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.75,"max":5.75},"Supply Current":{"unit":"mA","typ":90},"Operating Temperature":{"unit":"°C","min":0,"max":45},"Effective Range":{"Pieces Per Liter":{"unit":"pcs/liter","min":0,"max":28000},"Pieces Per 0.01 Cubic Foot":{"unit":"pcs/0.01cf","min":0,"max":8000}},"Particle Diameter":{"unit":"um","size":">1"}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Dust-Sensor-p-1050.html","http://wiki.seeed.cc/Grove-Dust_Sensor/"],"Datasheets":["https://github.com/SeeedDocument/Grove_Dust_Sensor/raw/master/resource/Grove_-_Dust_sensor.pdf"]}}}},{"Library":"pulsensor","Description":"Pulse Sensor library","Sensor Class":{"pulsensor":{"Name":"C++ API for the Adafruit 3-Wire Pulse Sensor","Description":"This is the UPM Module for the Adafruit 3-Wire Pulse Sensor. It can be used by students, artists, athletes, makers, and game & mobile developers who want to easily incorporate live heart-rate data into their projects.","Aliases":["pulsensor","Pulse Sensor Amped"],"Categories":["other"],"Connections":["analog"],"Project Type":["medical","prototyping"],"Manufacturers":["Adafruit"],"Image":"pulsensor.jpg","Examples":{"Java":["PulsensorSample.java"],"C++":["pulsensor.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1093","https://media.digikey.com/pdf/Data%20Sheets/Pulse%20PDFs/PulseSensorAmpedGettingStartedGuide.pdf"]}}}},{"Library":"relaylib","Description":"Grove Relay library","Sensor Class":{"relay":{"Name":"API for the Grove Relay","Description":"This is the UPM Module for the Grove Relay. UPM module for the relay switch. The relay is a digital normally-open switch that uses low voltage or current to control a higher voltage and/or higher current.  When closed, the indicator LED (if present) lights up and current is allowed to flow.","Aliases":["relay","Grove - Relay"],"Categories":["relay"],"Connections":["gpio"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["Seeed"],"Kits":["gsk","eak","hak"],"Image":"relay.jpg","Examples":{"Java":["RelaySample.java"],"Python":["relay.py"],"Node.js":["relay.js"],"C++":["relay.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","min":60,"max":100},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Relay Life":{"unit":"Cycles","typ":100000},"Max AC Switching Voltage":{"unit":"V","max":250},"Max DC Switching Voltage":{"unit":"V","max":30},"Max Switching Current":{"unit":"A","max":5}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Relay-p-769.html","http://wiki.seeed.cc/Grove-Relay/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Relay/master/res/Relay_Datasheet.pdf"]}}}},{"Library":"rf22","Description":"SparkFun/HopeRF RF22 Wireless Transceiver library","Sensor Class":{"rf22":{"Name":"API for the SparkFun/HopeRF RF22 Transceiver Module","Description":"This is the UPM Module for the SparkFun/HopeRF RF22 Transceiver Module. This base class provides basic functions for sending and receiving unaddressable, unreliable datagrams of arbitrary length to 255 octets per packet. Subclasses may use this class to implement reliable, addressed datagrams and streams,  mesh routers, repeaters, translators etc. On transmission, the TO and FROM addresses default to 0x00, unless changed by a subclass.  On reception the TO addressed is checked against the node address (defaults to 0x00) or the broadcast address (which is 0xff). The ID and FLAGS are set to 0, and not checked by this class. This permits use of the this base RF22 class as an unaddressable, unreliable datagram service. Subclasses are expected to change this behavior to add node address, ids, retransmission etc. Naturally, for any 2 radios to communicate that must be configured to use the same frequency and  modulation scheme.","Aliases":["rf22","RFM22B-S2 SMD Wireless Transceiver - 915MHz"],"Categories":["wifi"],"Connections":["spi"],"Project Type":["prototyping","commercial"],"Manufacturers":["SparkFun","HopeRF"],"Image":"rf22.jpg","Examples":{"C++":["rf22-client.cxx","rf22-server.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.8,"max":3.6},"Supply Current":{"Standby Mode":{"unit":"nA","min":450,"max":800},"Standard Usage":{"unit":"mA","min":8.5,"max":85}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Data Rate":{"unit":"kbps","min":0.123,"max":256}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/12030"],"Datasheets":["https://www.sparkfun.com/datasheets/Wireless/General/RFM22B.pdf"]}}}},{"Library":"rfr359f","Description":"Seeed RFR359 Distance Interrupter library","Sensor Class":{"rfr359f":{"Name":"API for the RFR359F-based Grove Distance Interrupter","Description":"This is the UPM Module for the RFR359F-based Grove Distance Interrupter. The sensitivity can be adjusted with the potentiometer on the sensor module. It has a range of approximately 4 inches and a quick response time.","Aliases":["rfr359f","Grove - IR Distance Interrupter"],"Categories":["light"],"Connections":["gpio"],"Project Type":["prototyping","industrial"],"Manufacturers":["Seeed"],"Kits":["robot","tsk"],"Image":"rfr359f.jpg","Examples":{"Java":["RFR359FSample.java"],"Python":["rfr359f.py"],"Node.js":["rfr359f.js"],"C++":["rfr359f.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","min":1,"max":20},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Distance":{"unit":"cm","min":7.5,"max":40}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-IR-Distance-Interrupter-p-1278.html","http://wiki.seeed.cc/Grove-IR_Distance_Interrupter_v1.2/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-IR_Distance_Interrupter_v1.2/master/res/Reflective_photosensor.pdf","https://raw.githubusercontent.com/SeeedDocument/Grove-IR_Distance_Interrupter_v1.2/master/res/LM393.pdf"]}}}},{"Library":"rgbringcoder","Description":"SparkFun RGB RingCoder Library","Sensor Class":{"rgbringcoder":{"Name":"API for the SparkFun RGB RingCoder","Description":"This is the UPM Module for the SparkFun RGB RingCode. RGB RingCoder is a breakout board, a circular LED containing 16 LEDs arranged in a ring, and a rotary encoder. The encoder contains an RGB LED as well as a push button function. NOTE: This SparkFun product is retired, and no longer for sale.","Aliases":["rgbringcoder","SparkFun LED RingCoder Breakout - RGB"],"Categories":["led"],"Connections":["pwm","gpio"],"Project Type":["prototyping"],"Manufacturers":["SparkFun"],"Image":"rgbringcoder.jpg","Examples":{"Python":["rgbringcoder.py"],"Node.js":["rgbringcoder.js"],"C++":["rgbringcoder.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/retired/11040"],"Datasheets":["https://github.com/sparkfun/LED_RingCoder_Breakout"]}}}},{"Library":"rhusb","Description":"Omega RH-USB Temperature and Humidity Sensor Library","Sensor Class":{"rhusb":{"Name":"API for the Omega RH-USB Temperature and Humidity Sensor","Description":"This is the UPM Module for the Omega RH-USB Temperature and Humidity Sensor. It connects via an integrated USB cable, and is accessed via a serial port.  It is suitable for wall or duct mounting.","Aliases":["rhusb","Humidity & Temperature Sensor with USB Output"],"Categories":["humidity","temperature"],"Connections":["uart"],"Project Type":["industrial","commercial"],"Manufacturers":["Omega"],"Image":"rhusb.jpg","Examples":{"Python":["rhusb.py"],"Node.js":["rhusb.js"],"C++":["rhusb.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":5,"max":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Temperature":{"Effective Range":{"unit":"°C","min":-17,"max":49},"Accuracy":{"unit":"°C","min":-1,"max":1}},"Relative Humidity":{"Effective Range":{"unit":"RH","min":"2%","max":"98%"},"Accuracy":{"unit":"RH","min":"-3%","max":"3%"}}},"Urls":{"Product Pages":["http://www.omega.com/pptst/RH-USB.html"],"Datasheets":["http://www.omega.com/das/pdf/RH-USB.pdf"]}}}},{"Library":"rn2903","Description":"Microchip RN2903 LoRa radio Library","Sensor Class":{"rn2903":{"Name":"API for the Microchip RN2903 LoRa radio","Description":"This is the UPM Module for the Microchip RN2903 LoRa radio. The RN2903 is a fully-certified 915 MHz module based on wireless LoRa technology.  The RN2903 utilizes a unique spread spectrum modulation within the Sub-GHz band to enable long range, low power, and high network capacity.","Aliases":["rn2903"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["prototyping","commercial"],"Manufacturers":["Microchip"],"Image":"rn2903.jpg","Examples":{"Java":["RN2903_Example.java","RN2903_P2P_RX_Example.java","RN2903_P2P_TX_Example.java"],"Python":["rn2903-p2p-rx.py","rn2903-p2p-tx.py","rn2903.py"],"Node.js":["rn2903-p2p-rx.js","rn2903-p2p-tx.js","rn2903.js"],"C++":["rn2903-p2p-rx.cxx","rn2903-p2p-tx.cxx","rn2903.cxx"],"C":["rn2903-p2p-rx.c","rn2903-p2p-tx.c","rn2903.c"]},"Specifications":{"Vsource":{"unit":"V","min":2.1,"max":3.6},"Supply Current":{"unit":"mA","min":185,"max":200},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Frequency Band":{"unit":"MHz","min":902,"max":928},"Effective Range":{"unit":"km","min":5,"max":15}},"Urls":{"Product Pages":["http://www.microchip.com/wwwproducts/en/RN2903"],"Datasheets":["http://ww1.microchip.com/downloads/en/DeviceDoc/50002390C.pdf"]}}}},{"Library":"rotary","Description":"Seeed Rotary Angle Sensor library","Sensor Class":{"rotary":{"Name":"API for the Seeed Rotary Angle Sensor","Description":"This is the UPM Module for the Seeed Rotary Angle Sensor. Provides a set of functions to read the absolute pin value, degrees or radians, and another set to do the same relative to the center of the knob's range.","Aliases":["rotary","Grove - Rotary Angle Sensor"],"Categories":["ainput"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["gsk"],"Image":"rotary.jpg","Examples":{"Java":["RotarySample.java"],"Python":["rotary.py"],"Node.js":["rotary.js"],"C++":["rotary.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.75,"max":5.25},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Rotary Angle":{"unit":"°","min":0,"max":300}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Rotary-Angle-Sensor-p-770.html"],"Datasheets":["http://wiki.seeed.cc/Grove-Rotary_Angle_Sensor/"]}}}},{"Library":"rotaryencoder","Description":"Grove Rotary Encoder library","Sensor Class":{"rotaryencoder":{"Name":"API for the Grove Rotary Encoder","Description":"This is the UPM Module for the Grove Rotary Encoder. This rotary encoder encodes a rotation signal into electronic pulses that can be used to measure rotation and direction. It is useful in cases where a rotary knob is required, but using a potentiometer is not desirable. A rotary encoder can turn a full 360 degrees without a stop and does not place a resistive load on the circuit, as is the case with a potentiometer.","Aliases":["rotaryencoder","Rotary Encoder","Grove - Encoder"],"Categories":["other"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Kits":["hak"],"Image":"rotaryencoder.jpg","Examples":{"Java":["RotaryEncoderSample.java"],"Python":["rotaryencoder.py"],"Node.js":["rotaryencoder.js"],"C++":["rotaryencoder.cxx"],"C":["rotaryencoder.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.5,"max":5.5},"Supply Current":{"unit":"mA","min":10,"max":30},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Rotary Angle":{"unit":"°","min":0,"max":360}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Encoder-p-1352.html"],"Datasheets":["http://wiki.seeed.cc/Grove-Encoder/"]}}}},{"Library":"rpr220","Description":"ROHM Semiconductor RPR220 IR Reflective Sensor library","Sensor Class":{"rpr220":{"Name":"API for the ROHM Semiconductor RPR220-based Grove IR Reflective Sensor","Description":"This is the UPM Module for the ROHM Semiconductor RPR220-based Grove IR Reflective Sensor. The reflectivity of infrared light varies with the color and distance of the reflecting surface. According to this principle, Grove - Infrared Reflective Sensor utilizes a RPR220 reflective photosensor module to detect color and distance. When a light-colored object approaches,the signal intensity received by infrared reflective sensor increases and the indicator LED on board turns red. When a dark-colored object approaches, the intensity decreases and the LED turns off.","Aliases":["rpr220","Grove - Infrared Reflective Sensor"],"Categories":["light"],"Connections":["gpio"],"Project Type":["mprototyping","commercial"],"Manufacturers":["ROHM Semiconductor","Seeed"],"Kits":["tsk","hak"],"Image":"rpr220.jpg","Examples":{"Java":["RPR220Sample.java","RPR220_intrSample.java"],"Python":["rpr220.py"],"Node.js":["rpr220.js"],"C++":["rpr220-intr.cxx","rpr220.cxx"],"C":["rpr220-intr.c","rpr220.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","min":14.69,"max":15.35},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Effective Distance":{"unit":"mm","min":4,"max":15},"Response Time":{"unit":"us","typ":10}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Infrared-Reflective-Sensor-p-1230.html","http://wiki.seeed.cc/Grove-Infrared_Reflective_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Infrared_Reflective_Sensor/master/res/RPR220_datasheet.pdf"]}}}},{"Library":"rsc","Description":"Honeywell TruStability Pressure and Temperature Sensor Library","Sensor Class":{"RSC":{"Name":"SPI based Board Mount Pressure and Temperature","Description":"The RSC Series is a piezoresistive silicon pressure sensor offering a digital output for reading pressure over the specified full scale pressure span and temperature range. It is calibrated and temperature compensated for sensor offset, sensitivity, temperature effects, and non-linearity using a 24-bit analog-todigital converter with integrated EEPROM. Pressure data may be acquired at rates between 20 and 2000 samples per second over an SPI interface. It is intended for use with non-corrosive, non-ionic gases, such as air and other dry gases, designed and and RoHS compliant. Most of the functionality available on this chip has been implemented. The driver calculates the compensated pressure and temperature values based on the information provided in the datasheet. The user must not mess around with the coefficient and adc init value readings from the EEPROM as these are used to calculate the compensated pressure and temperature values. In order to get the sensor to work properly on an Edison, you would need to turn off the Edison SPI power management, this can be done with the command: echo on > /sys/devices/pci0000\\:00/0000\\:00\\:07.1/power/control. You might have to use external pull up resistors on all the lines. More info about this has been provided in the datasheet with a table and a diagram.","Aliases":["rsc"],"Categories":["pressure","temperature"],"Connections":["gpio","spi"],"Project Type":["medical","industrial","extended"],"Manufacturers":["Honeywell"],"Kits":[],"Examples":{"Python":["rsc.py"],"Node.js":["rsc.js"],"C++":["rsc.cxx"],"C":["rsc.c"]},"Specifications":{"Vsupply":{"unit":"Vdc","min":2.7,"high":6},"Supply Current(3.3 Vdc)":{"unit":"mA","standby":1.3,"active":1.7},"Supply Current(5.0 Vdc)":{"unit":"mA","standby":2.1,"active":2.6},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start up Time":{"unit":"ms","time":0.3},"Compensated Temperature Range (Medical)":{"unit":"°C","min":0,"max":50},"Compensated Temperature Range (Industrial)":{"unit":"°C","min":-20,"max":85},"Compensated Temperature Range (Extended)":{"unit":"°C","min":-40,"max":85},"Data Rate":{"unit":"samples per second","min":20,"max":2000},"Pressure Range":{"Absolute":[{"unit":"bar","min":0,"max":10},{"unit":"kPa","min":0,"max":600},{"unit":"MPa","min":0,"max":1},{"unit":"psi","min":0,"max":150}],"Differential":[{"unit":"mbar","min":1.6,"max":600},{"unit":"bar","min":1,"max":10},{"unit":"Pa","min":160,"max":600},{"unit":"kPa","min":1,"max":600},{"unit":"MPa","max":1},{"unit":"inH2O","min":0.5,"max":30},{"unit":"psi","min":1,"max":150}],"Gage":[{"unit":"mbar","min":0,"max":600},{"unit":"bar","min":0,"max":10},{"unit":"Pa","min":0,"max":600},{"unit":"kPa","min":0,"max":600},{"unit":"MPa","min":0,"max":1},{"unit":"inH2O","min":0,"max":30},{"unit":"psi","min":0,"max":150}]}},"// Platforms":{"comment":"Catch-all for listing platforms used to validate this sensor class.","required":false},"Platforms":{"Intel Joule Module":{"Notes":["Might Require pull-up resistors or use a shield instead"]},"Intel Edison":{"Notes":["Turn of SPI power management to use the sensor. Turn it off using the command : echo on > /sys/devices/pci0000\\:00/0000\\:00\\:07.1/power/control"]},"Arduino 101":{"Notes":["Might need pull up resistors or a shield"]}},"Urls":{"Product Pages":["https://sensing.honeywell.com/sensors/amplified-board-mount-pressure-sensors/trustability-rsc-series"],"Datasheets":["https://sensing.honeywell.com/honeywell-sensing-trustability-rsc-series-data-sheet-32321348-b-en.pdf"]}}}},{"Library":"scam","Description":"Seeed Serial Camera library","Sensor Class":{"scam":{"Name":"API for the Seeed Serial Camera","Description":"This is the UPM Module for the Seeed Serial Camera. There is no protocol documentation currently available, so this module was developed based completely on the Seeed Studio* Arduino* sketch.","Aliases":["scam","Grove - Serial Camera Kit"],"Categories":["other"],"Connections":["uard"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Image":"scam.jpg","Examples":{"Java":["SCAMSample.java"],"Python":["scam.py"],"Node.js":["scam.js"],"C++":["scam.cxx"]},"Specifications":{"Vsource":{"unit":"V","typ":5},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"pixels","res":"160x120"},"UART Baud Rate":{"unit":"Baud","min":9600,"max":115200}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-Serial_Camera_Kit/"]}}}},{"Library":"sensortemplate","Description":"Library block provides a short library description","Sensor Class":{"sensortemplate":{"Name":"Short class/sensor description","Description":"Then add a much more detailed description here.  Include items such as board-specifics, testing, etc...","Aliases":["sensortemplate"],"Categories":["One or more of: accelerometer, ainput, button, color, compass, digipot, display, electric, flexfor, gaseous, gps, led, light, liquid, medical, motor, other, pressure, relay, rfid, serial, servos, sound, temp, time, touch, video, wifi"],"Connections":["analog, gpio, i2c, pwm, spi, uart"],"Project Type":["General idea of the project this sensor or class would fit in."],"Manufacturers":["One or more of: Sensor manufacturer. Can be 'generic'."],"Kits":["gsk, hak, eak, tsk, robok"],"Image":"sensortemplate.jpg","Examples":{"Java":["SensorTemplateSample.java"],"Python":["sensortemplate.py"],"Node.js":["sensortemplate.js"],"C++":["sensortemplate.cxx"]},"Specifications":{"Uses":{"Uses":"Used to display voltage, current, operating temperature, and other basic information a user would want in a glance."}},"Platforms":{"Intel Joule Module":{"Notes":["Notes on usage for the sensor or library with the Intel Joule Module"]},"Intel Edison":{"Notes":["Notes on usage for the sensor or library with the Intel Edison"]},"Arduino 101":{"Notes":["Notes on usage for the sensor or library with the Arduino 101"]}},"Urls":{"Product Pages":["URL to a product page or pages of the hardware mentioned"],"Datasheets":["URL to a datasheet or datasheets of the hardware mentioned"],"Schematics":["URL to a schematic or schematics of the hardware mentioned"]}}}},{"Library":"Servo","Description":"Servo Library","Sensor Class":{"ES9257":{"Name":"Micro Digital 3D Tail Servo","Description":"The ES9257 servo is a fast, heavy duty servo that is popular for moving control surfaces on RC models.","Aliases":["ES9257"],"Categories":["servos"],"Connections":["pwm"],"Project Type":["prototyping"],"Manufacturers":["emax"],"Image":"es9257.jpg","Examples":{"C":["servo.c"]},"Specifications":{"Vdd":{"unit":"v","typical":4.8},"Stall Torque":{"unit":"Kgf.cm","low":2.5},"Operating Speed (no load)":{"unit":"sec / 60 deg","max":0.08},"Pulse Cycle":{"unit":"ms","typical":3}},"Urls":{"Product Pages":["https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html"]}}}},{"Library":"servo","Description":"Servo Library","Sensor Class":{"es08a":{"Name":"API for the EMAX/Seeed ES08A Servo","Description":"This is the UPM Module for the EMAX/Seeed ES08A Servo. Like other servos, the ES08A servo has a shaft that can be controlled by setting the desired angle. There are also routines for setting and getting the minimum and maximum pulse width as well as the maximum period.","Aliases":["es08a","EMAX 9g ES08A High Sensitive Mini Servo"],"Categories":["servos"],"Connections":["pwm"],"Project Type":["prototyping","commercial"],"Manufacturers":["EMAX"],"Kits":["gsk"],"Image":"es08a.jpg","Examples":{"Java":["ES08ASample.java"],"Python":["es08a.py"],"Node.js":["es08a.js"],"C++":["servo-es08a.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.8,"max":6},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Operating Speed":{"unit":"Sec/60°","min":0.1,"max":0.12}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.seeedstudio.com/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html","https://www.emaxmodel.com/es08a-ii.html#product_tabs_description_tabbed"]}},"es9257":{"Name":"API for the EMAX ES9257 Servo","Description":"This is the UPM Module for the EMAX ES9257 Servo. The ES9257 servo is a fast, heavy duty servo that is popular for moving the control surfaces on RC models.","Aliases":["es9257","EMAX ES9257 2.5kg& .05 sec Micro Digital 3D Tail Servo"],"Categories":["servos"],"Connections":["pwm"],"Project Type":["prototyping","commercial"],"Manufacturers":["EMAX"],"Kits":["gsk"],"Image":"es9257.jpg","Examples":{"Python":["es08a.py"],"Node.js":["es08a.js"],"C++":["servo-es08a.cxx"]},"Specifications":{"Vsource":{"unit":"V","typ":4.8},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Operating Speed":{"unit":"Sec/60°","typ":0.08}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html"]}},"servo":{"Name":"Servo library","Description":"This is the UPM Module for the Servo library. The base Servo class provides routines for setting the angle of the shaft as well as setting and getting the minimum and maximum pulse width and  the maximum period.","Aliases":["servo"],"Categories":["servos"],"Connections":["pwm"],"Project Type":["prototyping","commercial"],"Manufacturers":["EMAX"],"Image":"es08a.jpg","Examples":{"Java":["ES08ASample.java"],"Python":["es08a.py","es08a.py"],"Node.js":["es08a.js","es08a.js"],"C++":["servo-es08a.cxx","servo-es08a.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.8,"max":6},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Operating Speed":{"unit":"Sec/60°","min":0.08,"max":0.12}},"Platforms":{"Intel Joule Module":{},"Intel Edison":{},"Arduino 101":{}},"Urls":{"Product Pages":["https://www.seeedstudio.com/EMAX-ES9257-2.5kg%26amp%3B-.05-sec-Micro-Digital-3D-Tail-Servo-p-762.html","https://www.seeedstudio.com/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html","https://www.emaxmodel.com/es08a-ii.html#product_tabs_description_tabbed"]}}}},{"Library":"sht1x","Description":"DFRobot SHT1X Temperature and Humidity Sensor Library","Sensor Class":{"sht1x":{"Name":"API for the DFRobot SHT1X Temperature and Humidity Sensor","Description":"This is the UPM Module for the DFRobot SHT1X Temperature and Humidity Sensor. SHT1x is individually calibrated in a precision humidity chamber. The calibration coefficients are programmed into an OTP memory on the chip. These coefficients are used to internally calibrate the signals from the sensors. The 2-wire serial interface and internal voltage regulation allows for easy and fast system integration. The tiny size and low power consumption makes SHT1x the ultimate choice for even the most demanding applications.","Aliases":["sht1x","SHT1x Humidity and Temperature Sensor (SKU: DFR0066)"],"Categories":["temperature","humidity"],"Connections":["gpio"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["DFRobot","Sensirion"],"Image":"sht1x.jpg","Examples":{"Java":["SHT1X_Example.java"],"Python":["sht1x.py"],"Node.js":["sht1x.js"],"C++":["sht1x.cxx"],"C":["sht1x.c"]},"Specifications":{"Vsource":{"unit":"V","min":2.4,"max":5.5},"Supply Current Digital":{"unit":"mA","typ":0.9},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Humidity Sensor":{"Measurement Range":{"unit":"%RH","min":0,"max":100},"Accuracy":{"unit":"%RH","min":-2,"max":2}},"Temperature Sensor":{"Measurement Range":{"unit":"°C","min":-40,"max":123.8},"Accuracy":{"unit":"°C","min":-0.3,"max":0.3}},"Response Time":{"unit":"second","typ":"< 4"}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.dfrobot.com/wiki/index.php/SHT1x_Humidity_and_Temperature_Sensor_(SKU:_DFR0066)"],"Datasheets":["https://www.sparkfun.com/datasheets/Sensors/SHT1x_datasheet.pdf"]}}}},{"Library":"si1132","Description":"Silicon Labs Si1132 UV and visible light sensor library","Sensor Class":{"si1132":{"Name":"API for the Silicon Labs Si1132 UV and Visible Light Sensor","Description":"This is the UPM Module for the Silicon Labs Si1132 UV and Visible Light Sensor. The Silicon Labs Si1132 is a low-power, ultraviolet (UV) index, and ambient light sensor with I2C digital interface and programmable-event interrupt output.","Aliases":["si1132"],"Categories":["light"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["Silicon Labs"],"Image":"si1132.jpg","Examples":{"C++":["si1132.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.71,"max":3.6},"Supply Current":{"Standby Mode":{"unit":"uA","min":"0.15","max":"1.4"},"Actively Measuring":{"unit":"mA","min":"4.3","max":"5.5"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Measurement Time":{"unit":"us","typ":285}},"Urls":{"Product Pages":["https://www.silabs.com/products/sensors/optical/si1132"],"Datasheets":["https://www.silabs.com/documents/public/data-sheets/Si1132.pdf"]}}}},{"Library":"si114x","Description":"Silicon Labs SI1145 UV Light Sensor library","Sensor Class":{"si114x":{"Name":"API for the Silicon Labs SI1145 UV Light Sensor","Description":"This is the UPM Module for the Silicon Labs SI1145 UV Light Sensor. This device is capable of measuring IR and visible ambient light as well. It also supports the ability to use externally attached LEDs to perform proximity detection on 3 separate channels. Currently, this class only supports the retrieving of the calculated UV index measured by the device, but enough infrastructure is provided to make it easy to enhance this driver in the future to support additional capabilities, including interrupt support.","Aliases":["si114x","SI1145 Digital UV Index / IR / Visible Light Sensor"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["Adafruit","Silicon Labs"],"Image":"si114x.jpg","Examples":{"Python":["si114x.py"],"Node.js":["si114x.js"],"C++":["si114x.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3,"max":5},"Supply Current":{"Standby Mode":{"unit":"uA","min":"0.15","max":"1.4"},"Actively Measuring":{"unit":"mA","min":"4.3","max":"5.5"}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Start-up Time":{"unit":"ms","time":25},"Measurement Time":{"unit":"us","min":155,"max":660}},"Platforms":{"Intel Joule Module":{"Notes":[]},"Intel Edison":{"Notes":[]},"Arduino 101":{"Notes":[]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1777"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/Si1145-46-47.pdf"]}}}},{"Library":"si7005","Description":"Silicon Labs SI7005 digital I2C humidity and temperature sensor library","Sensor Class":{"si7005":{"Name":"API for the Silicon Labs SI7005 digital I2C humidity and temperature sensor","Description":"This is the UPM Module for the Silicon Labs SI7005 digital I2C humidity and temperature sensor. The Si7005 sensor integrates humidity and temperature sensor elements and offers an analog-to-digital converter and signal processing in a single monolithic CMOS sensor IC. Both the humidity and temperature sensors are factory-calibrated and the data is stored in on-chip non-volatile memory.","Aliases":["si7005"],"Categories":["humidity","temperature"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["Silicon Labs"],"Image":"si7005.jpg","Examples":{"C++":["si7005.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.1,"max":3.6},"Supply Current Digital":{"unit":"uA","min":1,"max":565},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Conversion Time":{"unit":"ms","min":18,"max":40},"Wake-up Time":{"unit":"ms","min":10,"max":15},"Power-up Time":{"unit":"ms","min":10,"max":15}},"Urls":{"Product Pages":["https://www.silabs.com/products/sensors/humidity/si7005"],"Datasheets":["https://www.silabs.com/documents/public/data-sheets/Si7005.pdf"]}}}},{"Library":"slide","Description":"Seeed Slide Sensor library","Sensor Class":{"slide":{"Name":"API for the Seeed Slide Potentiometer","Description":"This is the UPM Module for the Seeed Slide Potentiometer. Basic UPM module for the slide potentiometer on analog that returns either a raw value or a scaled voltage value.","Aliases":["slide","Grove - Slide Potentiometer"],"Categories":["ainput"],"Connections":["analog"],"Project Type":["prototyping","robotics"],"Manufacturers":["Seeed"],"Image":"slide.jpg","Examples":{"Java":["SlideSample.java"],"Python":["slide.py"],"Node.js":["slide.js"],"C++":["slide.cxx"],"C":["slide.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":30},"Supply Current":{"unit":"mA","max":30},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Operational Life":{"unit":"cycles","typ":">15,000"},"Stroke Length":{"unit":"mm","length":30},"Total Resistance":{"unit":"Kohm","resistance":10}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Slide-Potentiometer-p-1196.html","http://wiki.seeed.cc/Grove-Slide_Potentiometer/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Slide_Potentiometer/master/res/Sliding_potentiometer_datasheet.pdf"]}}}},{"Library":"sm130","Description":"SonMicro SM130 RFID Reader Module library","Sensor Class":{"sm130":{"Name":"API for the SonMicro SM130 RFID Reader Module","Description":"This is the UPM Module for the SonMicro SM130 RFID Reader Module. This module defines the SM130 interface for the sm130 RFID library This module was developed using an SM130 and a Sparkfun RFID Evaluation shield using a UART for communications.  It should be fairly trivial to add support for I2C communication in the future, if you have the correct firmware on the SM130.","Aliases":["sm130"],"Categories":["rfid"],"Connections":["uart","gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["SonMicro","RFID Module - SM130 MIFARE (13.56 MHz)"],"Image":"sm130.jpg","Examples":{"Java":["SM130Example.java"],"Python":["sm130.py"],"Node.js":["sm130.js"],"C++":["sm130.cxx"],"C":["sm130.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.85,"max":5.5},"Supply Current":{"unit":"mA","min":0.03,"max":180},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/10126"],"Datasheets":["https://www.sparkfun.com/datasheets/Sensors/ID/SM130.pdf"]}}}},{"Library":"smartdrive","Description":"SmartDrive library","Sensor Class":{"smartdrive":{"Name":"API for the SmartDrive advanced motor controller from OpenElectronics","Description":"This is the UPM Module for the OpenElectronics SmartDrive advanced motor controller. SmartDrive is a multiplexer to control high current DC motors This module has been tested on the SmartDrive.","Aliases":["smartdrive","SmartDrive High Current Motor Controller"],"Categories":["motor"],"Connections":["i2c"],"Project Type":["prototyping","robotics"],"Manufacturers":["OpenElectronics"],"Image":"smartdrive.jpg","Examples":{"C++":["smartdrive.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":12,"max":24},"Supply Current":{"unit":"A","average":10,"max":30},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Controllable Motors":{"unit":"motors","motors":2}},"Urls":{"Product Pages":["http://www.mindsensors.com/rpi/76-smartdrive-high-current-motor-controller"]}}}},{"Library":"speaker","Description":"Seeed Speaker library","Sensor Class":{"speaker":{"Name":"API for the Seeed Speaker","Description":"This is the UPM Module for the Seeed Speaker. This speaker can generate different tones and sounds depending on the frequency of the input signal. It can operate in one of two modes: GPIO (default) and PWM. Depending on which mode is selected, some methods may not be usable.  In GPIO mode, the playAll() and playSound() methods are supported.  In PWM mode, setFrequency(), emit(), on() and off() are supported.  Calling a method not appropriate for the mode will have no effect.","Aliases":["speaker","Grove - Speaker"],"Categories":["sound"],"Connections":["gpio","PWM"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["hak"],"Image":"speaker.jpg","Examples":{"Java":["SpeakerPWMSample.java","SpeakerSample.java"],"Python":["speaker_pwm.py","speaker.py"],"Node.js":["speaker_pwm.js","speaker.js"],"C++":["speaker-pwm.cxx","speaker.cxx"],"C":["speaker-pwm.c","speaker.c"]},"Specifications":{"Vsource":{"unit":"V","min":4,"max":5.5},"Supply Current":{"unit":"mA","min":4,"max":8},"Operating Temperature":{"unit":"°C","min":0,"max":70}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Speaker-p-1445.html","http://wiki.seeed.cc/Grove-Speaker/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Speaker/master/res/LM386_Low_Voltage_Audio_Power_Amplifier_Datasheet.pdf"]}}}},{"Library":"ssd1351","Description":"Adafruit SSD1351 OLED library","Sensor Class":{"ssd1351":{"Name":"API for the Adafruit SSD1351 OLED displays","Description":"This is the UPM Module for the Adafruit SSD1351 OLED displays. It was tested with the Adafruit 1.5\" OLED Display, but should work with any SSD1351 display running in SPI mode. On the Intel Edison don't forget to disable SPI Power Management (PM) for this driver to work, you can find more details on this topic here: http://iotdk.intel.com/docs/master/mraa/edison.html","Aliases":["ssd1351","OLED Breakout Board - 16-bit Color 1.5\" w/microSD holder"],"Categories":["display"],"Connections":["spi"],"Project Type":["prototyping","commercial"],"Manufacturers":["Adafruit","Slomon Systech","Univision"],"Image":"ssd1351.jpg","Examples":{"C++":["ssd1351.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"uA","min":10,"max":1260},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"pixels","height":128,"width":128},"Color Resolution":{"unit":"bits","resolution":14}},"Urls":{"Product Pages":["https://www.adafruit.com/product/1431"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/SSD1351-Revision+1.3.pdf","https://cdn-shop.adafruit.com/datasheets/UG-2828GDEDF11.pdf"]}}}},{"Library":"st7735","Description":"Adafruit ST7735 LCD library","Sensor Class":{"st7735":{"Name":"API for the Adafruit ST7735 LCD","Description":"This is the UPM Module for the Adafruit ST7735 LCD. This lovely little display breakout is the best way to add a small, colorful and bright display to any project. Since the display uses 4-wire SPI to communicate and has its own pixel-addressable frame buffer, it can be used with every kind of microcontroller. Even a very small one with low memory and few pins available!","Aliases":["st7735","1.8\" Color TFT LCD display with MicroSD Card Breakout - ST7735R"],"Categories":["display"],"Connections":["spi"],"Project Type":["prototyping","commercial"],"Manufacturers":["Adafruit","Truly Semiconductors","Sitronix"],"Image":"st7735.jpg","Examples":{"Java":["ST7735Sample.java"],"Node.js":["st7735.js"],"C++":["st7735.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","min":1,"max":50},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"pixels","height":128,"width":160},"Color Resolution":{"unit":"bits","resolution":18}},"Urls":{"Product Pages":["https://www.adafruit.com/product/358"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/JD-T1800.pdf","https://cdn-shop.adafruit.com/datasheets/ST7735R_V0.2.pdf"]}}}},{"Library":"stepmotor","Description":"Stepper Motor library","Sensor Class":{"stepmotor":{"Name":"API for the Stepper Motor","Description":"This is the UPM Module for the API for the Stepper Motor. This module defines the Stepper Motor interface. It is compatible with stepper motor drivers that use 2 pins to control the motor, like an Easy Driver from Brian Schmalz or the STR driver series from Applied Motion. It can also control an enable pin if one is available and connected. The implementation is synchronous and thus blocking while the stepper motor is in motion. However it is possible to send the commands via threading and the performance of the library will be very good given a low CPU load. On a busy system though you will notice some jitter especially at higher speeds. It is possible to reduce this effect to some extent by using smoothing and/or microstepping on stepper drivers that support such features.","Aliases":["stepmotor","EasyDriver - Stepper Motor Driver"],"Categories":["motor"],"Connections":["gpio"],"Project Type":["prototyping","robotics","commercial"],"Manufacturers":["Allegro","SparkFun","generic"],"Image":"stepmotor.jpg","Examples":{"Java":["StepMotorSample.java"],"Python":["stepmotor.py"],"Node.js":["stepmotor.js"],"C++":["stepmotor.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":7},"Motor Driver Voltage":{"unit":"V","min":6,"max":30},"Supply Current":{"unit":"mA","min":150,"max":700},"Operating Temperature":{"unit":"°C","min":-20,"max":85}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/12779"],"Datasheets":["https://cdn.sparkfun.com/datasheets/Robotics/A3967-Datasheet.pdf"]}}}},{"Library":"sx1276","Description":"Semtech SX1276 LoRa/FSK Modem Library","Sensor Class":{"SX1276":{"Name":"Semtech SX1276 LoRa/FSK Module","Description":"The SX1276 is a FSK/OOK/LoRa modem capable of both Low Frequency and High Frequency communication. It requires a 3.3v power supply, do not use 5v. Frequency Hopping Spread Spectrum (FHSS) is not currently supported.","Aliases":["sx1276"],"Categories":["radio"],"Connections":["gpio","spi"],"Project Type":["industrial"],"Manufacturers":["semtech"],"Examples":{"Python":["sx1276-fsk.py","sx1276-lora.py"],"Node.js":["sx1276-fsk.js","sx1276-lora.js"],"C++":["sx1276-fsk.cxx","sx1276-lora.cxx"]},"Specifications":{"VDDmr":{"unit":"V","min":-0.5,"max":3.9},"VDDop":{"unit":"V","min":1.8,"max":3.7},"Tmr":{"unit":"�C","min":-55,"max":115},"Top":{"unit":"�C","min":-40,"max":85},"IDDsl":{"unit":"uA","typ":0,"max":1},"IDDidle":{"unit":"uA","typ":1.5},"IDDst":{"unit":"mA","typ":1.6,"max":1.8},"IDDfs":{"unit":"mA","typ":5.8},"IDDr":[{"Conditions":"LnaBoost Off, band 1","unit":"mA","typ":10.8},{"Conditions":"LnaBoost On, band 1","unit":"mA","typ":11.5},{"Conditions":"bands 2 & 3","unit":"mA","typ":12}],"IDDt":[{"Conditions":"RFOP +20 dBm on PA_BOOST","unit":"mA","typ":120},{"Conditions":"RFOP +17 dBm on PA_BOOST","unit":"mA","typ":87},{"Conditions":"RFOP +13 dBm on RFO_LH/RH pin","unit":"mA","typ":29},{"Conditions":"RFOP +7 dBm on RFO_LH/RH pin","unit":"mA","typ":20}],"LoRaWAN Band":"US915","Range":"Claimed > 10km","Packet Size":{"unit":"bytes","max":256}},"Platforms":{"Intel Edison":{"Notes":["Power using 3.3 V"]},"Arduino 101":{"Notes":["Power using 3.3 V"]},"Intel C1000":{"Notes":["Power using 3.3 V"]}},"Urls":{"Product Pages":["http://www.semtech.com/wireless-rf/rf-transceivers/sx1276/"],"Datasheets":["http://www.semtech.com/images/datasheet/sx1276.pdf"]}}}},{"Library":"sx6119","Description":"Seeed SX6119-based FM Receiver library","Sensor Class":{"sx6119":{"Name":"API support for the Seeed SX6119-based Grove FM Receiver","Description":"This is the UPM Module for the Seeed SX6119-based Grove FM Receiver. There are two digital pins: one that toggles power on/off, and the other that does a seek to the next station.","Aliases":["sx6119","Grove - FM Receiver"],"Categories":["sound"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Image":"sx6119.jpg","Examples":{"Python":["sx6119.py"],"Node.js":["sx6119.js"],"C++":["sx6119.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2,"max":3.6},"Supply Current":{"unit":"mA","min":0.005,"max":17},"Operating Temperature":{"unit":"°C","min":-20,"max":85},"Start-up Time":{"unit":"ms","min":30,"max":150}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-FM-Receiver-p-1841.html","http://wiki.seeed.cc/Grove-FM_Receiver/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-FM_Receiver/master/res/SX6119_%E6%94%B6%E9%9F%B3IC_datasheet.pdf"]}}}},{"Library":"t3311","Description":"T3311 Temperature and Humidity Sensor Library","Sensor Class":{"t3311":{"Name":"API for the T3311 MODBUS Temperature and Humidity Sensor","Description":"This is the UPM Module for the T3311 MODBUS Temperature and Humidity Sensor. This module implements support for the Comet System T3311 Temperature and Humidity transmitter.  It uses MODBUS over an RS232 serial port.  You must have libmodbus v3.1.2 (or greater) installed to compile and use this driver. This module was developed using libmodbus 3.1.2, and T3311 Firmware revison 2.66 connected via a Prolific RS232 Serial to USB adaptor. You cannot use the built in TTL UART pins for accessing this device -- you must use a full serial RS232 interface connected via USB.","Aliases":["t3311","T3311 Temperature and humidity probe with RS232 output, internal sensors"],"Categories":["humidity","temperature"],"Connections":["uart"],"Project Type":["industrial"],"Manufacturers":["Comet"],"Image":"t3311.jpg","Examples":{"Python":["t3311.py"],"Node.js":["t3311.js"],"C++":["t3311.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":9,"max":30},"Operating Temperature":{"unit":"°C","min":-30,"max":85},"Temperature Sensor":{"Effective Range":{"unit":"°C","min":-30,"max":80},"Accuracy":{"unit":"°C","min":-0.4,"max":0.4}},"Humidity Sensor":{"Effective Range":{"unit":"RH","min":"0%","max":"100%"},"Accuracy":{"unit":"RH","min":"-2.5%","max":"2.5%"}}},"Urls":{"Product Pages":["http://www.cometsystem.com/products/reg-T3311"],"Datasheets":["http://www.cometsystem.com/products/reg-T3311#technical_dataa"]}}}},{"Library":"t6713","Description":"Amphenol Telaire 6713 Series CO2 Module Sensor Library","Sensor Class":{"t6713":{"Name":"API for the Amphenol Telaire 6713 Series CO2 Module","Description":"This is the UPM Module for the Amphenol Telaire 6713 Series CO2 Module. The new T6700 series is a miniature NDIR CO2 sensor that has accuracy and reliability of many larger sensors. The new small size allows OEM’s to integrate in to smaller enclosures and equipment and uses significantly less power than many other devices on the market.","Aliases":["t6713","Miniature CO2 Module Series T6700"],"Categories":["gaseous"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["Amphenol"],"Image":"t6713.jpg","Examples":{"C++":["t6713-co2-sensor.cxx","t6713.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":4.4,"max":5.5},"Supply Current":{"unit":"mA","min":25,"max":200},"Operating Temperature":{"unit":"°C","min":-10,"max":60},"Detection Range":{"unit":"ppm","min":400,"max":5000},"Accuracy":{"unit":"ppm","min":-75,"max":75}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700"],"Datasheets":["http://amphenol-sensors.com/en/products/co2/co2-modules/3215-t6700#specifications-t6703"]}}}},{"Library":"t8100","Description":"Amphenol Telaire Ventostat T8100 Ventilation Controller Library","Sensor Class":{"t8100":{"Name":"API for the Amphenol Telaire Ventostat T8100 Ventilation Controller","Description":"This is the UPM Module for the Amphenol Telaire Ventostat T8100 Ventilation Controller. This module implements support for the Amphenol Telaire Ventostat T8100 Ventilation Controller with BACnet interface.  It may also support the T8200 and T8300 models, but they have not been tested. The Telaire Ventostat T8100 reports Temperature, Humidity and CO2 concentrations.  It supports an optional relay with a settable trigger point.  The unit this driver was tested under did not support the optional relay.","Aliases":["t8100","Telaire Ventostat Series CO2 Monitor"],"Categories":["gaseous","temperature","humidity"],"Connections":["uart"],"Project Type":["industrial","commercial"],"Manufacturers":["Amphenol"],"Image":"t8100.jpg","Examples":{"Java":["T8100_Example.java"],"Python":["t8100.py"],"Node.js":["t8100.js"],"C++":["t8100.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":0,"max":10},"Supply Current":{"unit":"mA","min":4,"max":20},"Operating Temperature":{"unit":"°C","min":0,"max":50},"Temperature Sensor":{"Effective Range":{"unit":"°C","min":0,"max":50},"Accuracy":{"unit":"°C","min":-0.8,"max":0.8}},"Humidity Sensor":{"Effective Range":{"unit":"RH","min":"0%","max":"99%"},"Accuracy":{"unit":"RH","min":"-3.5%","max":"3.5%"}},"CO2 Sensor":{"Effective Range":{"unit":"ppm","min":0,"max":5000},"Accuracy":{"unit":"ppm","min":-30,"max":30},"Warm-up Time":{"unit":"minutes","min":2,"max":10}}},"Urls":{"Product Pages":["https://www.instrumart.com/products/18180/telaire-ventostat-series-co2-monitor"],"Datasheets":["https://www.instrumart.com/assets/Telaire_Ventostat_Wall_Mount-datasheet.pdf"]}}}},{"Library":"ta12200","Description":"Seeed TA12-200 Current Transformer library","Sensor Class":{"ta12200":{"Name":"API for the Seeed TA12-200 Current Transformer","Description":"This is the UPM Module for the Seeed TA12-200 Current Transformer. The Electricity sensor module is based on the TA12-200 current transformer which can change large alternating current into a small amplitude. You can use it to test large alternating current upto 5A.","Aliases":["ta12200","Grove - Electricity Sensor"],"Categories":["electric"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Image":"ta12200.jpg","Examples":{"Python":["ta12200.py"],"Node.js":["ta12200.js"],"C++":["ta12200.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Sampling Voltage":{"unit":"V","min":0,"max":2},"Supply Current":{"unit":"A","min":0,"max":5},"Output Current":{"unit":"mA","min":0,"max":2.5},"Operating Temperature":{"unit":"°C","min":-55,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Electricity-Sensor-p-777.html","http://wiki.seeed.cc/Grove-Electricity_Sensor/"]}}}},{"Library":"tb7300","Description":"Honeywell TB7300 Communicating Fan Coil Thermostat Library","Sensor Class":{"tb7300":{"Name":"API for the Honeywell TB7300 Communicating Fan Coil Thermostat","Description":"This is the UPM Module for the Honeywell TB7300 Communicating Fan Coil Thermostat. It may also support the TB7200, though only the TB7300 was available for development of this driver. The TB7200 Series PI thermostats are designed for zoning applications, and the TB7300 Series PI thermostats are designed for fan coil control. Both Series are communicating thermostats with models available in BACnet(r) MS/TP protocol and can be easily integrated into a WEBs-AX building automation system based on the NiagaraAX(r) platform. TB7200 and TB7300 Series thermostats are compatible with the Honeywell Occupancy Sensor Cover. Thermostats equipped with an occupancy sensor cover provide advanced active occupancy logic, which will automatically switch occupancy levels from Occupied to Stand-By and Unoccupied as required by local activity being present or not. This advanced occupancy functionality provides advantageous energy savings during occupied hours without sacrificing occupant comfort. All thermostats can be ordered with or without a factory installed PIR cover.","Aliases":["tb7300","TB7300C5014B"],"Categories":["temperature"],"Connections":["uart"],"Project Type":["industrial","commercial"],"Manufacturers":["honeywell"],"Image":"tb7300.jpg","Examples":{"Java":["TB7300_Example.java"],"Python":["tb7300.py"],"Node.js":["tb7300.js"],"C++":["tb7300.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":19,"max":30},"Supply Current":{"unit":"A","min":1,"max":3},"Operating Temperature":{"unit":"°C","min":0,"max":50},"Operating Humidity":{"unit":"RH","min":"0%","max":"95%"}},"Urls":{"Product Pages":["https://parts-hvac.com/tb7300c5014b.html"]}}}},{"Library":"tca9548","Description":"TI tca9548a multiplexer library","Sensor Class":{"TCA9548A":{"Name":"API for the TI TCA9548A Multiplexer Breakout","Description":"This is the UPM Module for the Texas Instruments TCA9548A Multiplexer Breakout.","Aliases":["TCA9548A","TCA9548A I2C Multiplexer"],"Categories":["multiplexer"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Adafruit","Texas Instruments"],"Image":"tca9548a.jpg","Examples":{"Node.js":["tca9548.js"],"C++":["tca9548a.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":1.65,"max":5.5},"Supply Current":{"unit":"uA","min":2,"max":80},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Supported Same Address i2c Devices":{"unit":"Devices","devices":8}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/2717","https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview"],"Datasheets":["https://cdn-shop.adafruit.com/datasheets/tca9548a.pdf"]}}}},{"Library":"tcs3414cs","Description":"Seeed TCS3414CS Color Sensor library","Sensor Class":{"tcs3414cs":{"Name":"API for the Seeed TCS3414CS Color Sensor","Description":"This is the UPM Module for the Seeed TCS3414CS Color Sensor. This module is based on the color sensor TCS3414CS with digital output I2C. Based on the 8*2 array of filtered photodiodes and 16-bit analog-to-digital converters, you can measure the color chromaticity of ambient light or the color of objects. Of the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters and 4 have no filter(clear). With the synchronization input pin, an external pulsed light source can provide precise synchronous conversion control.","Aliases":["tcs3414cs"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping"],"Manufacturers":["Seeed","TAOS","ams"],"Image":"tcs3414cs.jpg","Examples":{"Python":["tcs3414cs.py"],"Node.js":["tcs3414cs.js"],"C++":["tcs3414cs.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":6},"Supply Current":{"unit":"mA","min":1,"max":12},"Operating Temperature":{"unit":"°C","min":-30,"max":70}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-I2C_Color_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-I2C_Color_Sensor/master/res/TCS3404_TCS3414-A.pdf","https://github.com/SeeedDocument/Grove-I2C_Color_Sensor/raw/master/res/TCS3472%20Datasheet.pdf"]}}}},{"Library":"tcs37727","Description":"AMS TCS37727 Color Light-To-Digital Converter Library","Sensor Class":{"tcs37727":{"Name":"API for the AMS TCS37727 Color Light-To-Digital Converter","Description":"This is the UPM Module for the AMS TCS37727 Color Light-To-Digital Converter. The TCS3772 device family provides red, green, blue, and clear (RGBC) light sensing and, when coupled with an external IR LED, proximity detection. These devices detect light intensity under a variety of lighting conditions and through a variety of attenuation materials, including dark glass. The proximity detection feature allows a large dynamic range of operation for accurate short distance detection, such as in a cell phone, for detecting when the user positions the phone close to their ear. An internal state machine provides the ability to put the device into a low power state in between proximity and RGBC measurements providing very low average power consumption.","Aliases":["tcs37727"],"Categories":["color","light"],"Connections":["i2c"],"Project Type":["industrial","commercial"],"Manufacturers":["AMS"],"Image":"tcs37727.jpg","Examples":{"Python":["tcs37727.py"],"C++":["tcs37727.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.7,"max":3.6},"Supply Current":{"unit":"uA","min":2.5,"max":330},"Operating Temperature":{"unit":"°C","min":-30,"max":70}},"Urls":{"Product Pages":["http://ams.com/eng/Products/Light-Sensors"],"Datasheets":["http://ams.com/eng/content/download/291143/1065677/file/TCS3772_DS000175_2-00.pdf"]}}}},{"Library":"teams","Description":"Veris TEAMS Temperature Transmitter Library","Sensor Class":{"teams":{"Name":"API for the Veris TEAMS Temperature Transmitter","Description":"This is the UPM Module for the Veris TEAMS Temperature Transmitter. The Veris TEAMS temperature sensor provides it's output via a 4-20ma current loop. The supported temperature range is 10C to 35C. This sensor was developed with a Cooking Hacks (Libelium) 4-channel 4-20ma Arduino interface shield.  For this interface, the receiver resistance (rResistor) was specified as 165.0 ohms. When using a 4-20ma current loop interface which scales the sensors' values to a 0-5vdc range, you can supply 0.0 as the rResistor value in the constructor (default), and it will act just like a normal analog input.","Aliases":["teams"],"Categories":["temperature"],"Connections":["ainput"],"Project Type":["industrial","commercial"],"Manufacturers":["Veris"],"Image":"teams.jpg","Examples":{"Java":["TEAMS_Example.java"],"Python":["teams.py"],"Node.js":["teams.js"],"C++":["teams.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":5,"max":30},"Supply Current":{"unit":"mA","min":4,"max":20},"Operating Temperature":{"unit":"°C","min":-25,"max":105},"Accuracy":{"unit":"°C","min":-0.3,"max":0.3}},"Urls":{"Product Pages":["http://www.veris.com/Item/TEAMS.aspx"],"Datasheets":["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]}}}},{"Library":"temperature","Description":"Temperature sensor library","Sensor Class":{"Temperature":{"Name":"Analog Temperature Sensor","Description":"Basic UPM module for analog temperature sensors. These sensors use a NTC thermistor to measure ambient temperature. This driver was developed using the Grove Temperature Sensor. The conversion formula has been updated to work with versions 1.1 and 1.2 of the sensor. For the older v1.0 sensor you will have to specify R0 and B values when initializing the device. The range of this sensor is -40 to 125 C and accuracy is +/- 1.5 C.","Aliases":["Grove - Temperature Sensor"],"Categories":["temp"],"Connections":["analog"],"Project Type":["prototyping","industrial"],"Manufacturers":["seeed","dfrobot","sparkfun","adafruit","generic"],"Kits":["gsk"],"Image":"temp.jpg","Examples":{"Java":["TemperatureSample.java"],"Python":["temperature.py"],"Node.js":["temperature.js"],"C++":["temperature.cxx"]},"Platforms":{"Arduino 101":{"Notes":["Will need to adjust ADC scale when used with Grove Base Shield (see API documentation)."]}},"Urls":{"Product Pages":["http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2/"],"Datasheets":["https://github.com/SeeedDocument/Grove-Temperature_Sensor_V1.2/raw/master/res/NCP18WF104F03RC.pdf"],"Schematics":["https://easyeda.com/Seeed/Grove_Temperature_sensor_v1_2-ed433e462f14455e9aa38ae1a06e4680"]}}}},{"Library":"tex00","Description":"Veris TEX00 Temperature Sensor Library","Sensor Class":{"tex00":{"Name":"API for the Veris TEX00 Temperature Sensor","Description":"This is the UPM Module for the Veris TEX00 Temperature Sensor. The Veris TEX00 temperature sensor family is made up of a series of RTD thermistors in wall mount packaging.    This driver was developed using the TED00, which utilizes a 10K Ohm Type 2 thermistor.  However, this driver can support the other 12 variants of the TE series as well by providing the correct sensor type to the class constructor.  These other sensor types have not been tested.  Only the TED00 was tested with this driver.","Aliases":["tex00","TED00"],"Categories":["temperature"],"Connections":["ainput"],"Project Type":["industrial","commercial"],"Manufacturers":["Veris"],"Image":"tex00.jpg","Examples":{"Java":["TEX00_Example.java"],"Python":["tex00.py"],"Node.js":["tex00.js"],"C++":["tex00.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":5,"max":30},"Supply Current":{"unit":"mA","min":4,"max":20},"Operating Temperature":{"unit":"°C","min":-25,"max":105},"Effective Range":{"unit":"°C","min":10,"max":35},"Offset Temperature":{"unit":"+/-°C","min":1.8,"max":3}},"Urls":{"Product Pages":["http://www.veris.com/Item/TED00.aspx"],"Datasheets":["http://www.veris.com/docs/Datasheets/TW_TE_d0117.pdf"]}}}},{"Library":"th02","Description":"Seeed TH02 Temperature & Humidity Sensor Library","Sensor Class":{"th02":{"Name":"API for the Seeed TH02 Temperature & Humidity Sensor","Description":"This is the UPM Module for the Seeed TH02 Temperature & Humidity Sensor. This is a multifunctional sensor that gives you temperature and relative humidity information at the same time. It utilizes a TH02 sensor that can meet measurement needs of general purposes. It provides reliable readings when environment humidity condition inbetween 0-80% RH, and temperature condition inbetween 0-70°C, covering needs in most home and daily applications that don't contain extreme conditions.","Aliases":["th02","Grove - Temperature&Humidity Sensor (High-Accuracy & Mini)"],"Categories":["humidity","temperature"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Image":"th02.jpg","Examples":{"Java":["Th02Example.java"],"C++":["th02.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"uA","min":24,"max":565},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Humidity Sensor":{"Effective Range":{"unit":"%RH","min":20,"max":80},"Accuracy":{"unit":"-/+ %RH","min":3,"max":4.5}},"Temperature Sensor":{"Effective Range":{"unit":"°C","min":0,"max":70},"Resolution":{"unit":"°C","resolution":"1/32"},"Accuracy":{"unit":"+/- °C","min":0.5,"max":1}}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield","Must be set to 3 V rather than 5 V."]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Temperature%26Humidity-Sensor-(High-Accuracy-%26-Mini)-p-1921.html","http://wiki.seeed.cc/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-TemptureAndHumidity_Sensor-High-Accuracy_AndMini-v1.0/master/res/TH02_SENSOR.pdf"]}}}},{"Library":"tm1637","Description":"Seeed TM1637 based 7-Segment Display Library","Sensor Class":{"tm1637":{"Name":"API for the Seeed TM1637 based 7-Segment Display","Description":"This is the UPM Module for the Seeed TM1637 based 7-Segment Display. It can be used to address and write data to multiple display digits. This driver is based on the Grove version of the TM1637 display that uses 4 digits, thus making it ideal for clock displays, timers, counters, or even score displays in a two-player arcade game.","Aliases":["tm1637","Grove - 4-Digit Display"],"Categories":["display"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed","Titan Micro Electronics"],"Image":"tm1637.jpg","Examples":{"Java":["TM1637Sample.java"],"Python":["tm1637.py"],"Node.js":["tm1637.js"],"C++":["tm1637.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5.5},"Supply Current":{"unit":"mA","min":0.2,"max":80},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/grove-4digital-display-p-1198.html","http://wiki.seeed.cc/Grove-4-Digit_Display/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/TM1637_datasheet.pdf"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-4-Digit_Display/master/res/Grove_4-Digit_Display_V1.0.pdf"]}}}},{"Library":"tmp006","Description":"Texas Instruments TMP006 Infrared-Thermopile Sensor Library","Sensor Class":{"tmp006":{"Name":"API for the Texas Instruments TMP006 IR-Thermopile Sensor","Description":"This is the UPM Module for the Texas Instruments TMP006 IR-Thermopile Sensor. The TMP006 and TMP006B are fully integrated MEMs thermopile sensors that measure the temperature of an object without having to be in direct contact. The thermopile absorbs passive infrared energy from an object at wavelengths between 4 um to 16 um within the end-user defined field of view. The corresponding change in voltage across the thermopile is digitized and reported with the on-chip die thermal sensor measurement through an I2C- and SMBus-compatible interface. With this data, the target object temperature can be calculated by an external processor.","Aliases":["tmp006","TMP006 Infrared Thermopile Contactless Temperature Sensor in WCSP Package"],"Categories":["temperature"],"Connections":["i2c"],"Project Type":["prototyping","industrial","commercial"],"Manufacturers":["Texas Instruments"],"Image":"tmp006.jpg","Examples":{"Python":["tmp006.py"],"C++":["tmp006.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.5,"max":5.5},"Supply Current":{"unit":"uA","min":1,"max":325},"Operating Temperature":{"unit":"°C","min":-40,"max":125},"Effective Range":{"unit":"°C","min":0,"max":60},"Accuracy":{"unit":"-/+ °C","min":0.5,"max":1}},"Urls":{"Product Pages":["http://www.ti.com/product/TMP006/datasheet/abstract#SBOS5183423"],"Datasheets":["http://www.ti.com/lit/ds/symlink/tmp006.pdf"]}}}},{"Library":"tsl2561","Description":"TSL2561 Digital Light Sensor library","Sensor Class":{"tsl2561":{"Name":"API for the TSL2561 Digital Light Sensor","Description":"This is the UPM Module for the TSL2561 Digital Light Sensor. TSL2560 and TSL2561 are light-to-digital converters that transform light intensity to a digital signal output capable of a direct I2C (TSL2561) interface","Aliases":["tsl2561","Grove - Digital Light Sensor"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed","TAOS"],"Kits":["eak"],"Image":"tsl2561.jpg","Examples":{"Java":["TSL2561Sample.java","Tsl2561.java"],"Python":["tsl2561.py"],"Node.js":["tsl2561.js"],"C++":["tsl2561.cxx"],"C":["tsl2561.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5.1},"Supply Current":{"unit":"uA","min":240,"max":600},"Operating Temperature":{"unit":"°C","min":-30,"max":70},"Effective Range":{"unit":"Lux","min":0.1,"max":40000},"Conversion Time":{"unit":"ms","min":12,"max":400}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Digital-Light-Sensor-p-1281.html","http://wiki.seeed.cc/Grove-Digital_Light_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Digital_Light_Sensor/master/res/TSL2561T.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20Sch.pdf","https://github.com/SeeedDocument/Grove-Digital_Light_Sensor/raw/master/res/Digital%20light%20sensor%20v1.0%20PCB.pdf"]}}}},{"Library":"ttp223","Description":"Seeed TTP223 Touch Detector Sensor library","Sensor Class":{"ttp223":{"Name":"API for the Seeed TTP223 Touch Sensor","Description":"This is the UPM Module for the Seeed TTP223 Touch Sensor. This touch sensor detects when a finger is near the metallic pad by the change in capacitance. It can replace a more traditional push button. The touch sensor can still function when placed under a  non-metallic surface like glass or plastic.","Aliases":["ttp223","Grove - Touch Sensor"],"Categories":["touch"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Image":"ttp223.jpg","Examples":{"Java":["TTP223Sample.java"],"Python":["ttp223.py"],"Node.js":["ttp223.js"],"C++":["ttp223.cxx"],"C":["ttp223.c"]},"Specifications":{"Vsource":{"unit":"V","min":2,"max":5.5},"Supply Current":{"unit":"uA","min":1.5,"max":7},"Operating Temperature":{"unit":"°C","min":-20,"max":70},"Response Time":{"unit":"ms","min":60,"max":220}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Touch-Sensor-p-747.html","http://wiki.seeed.cc/Grove-Touch_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/TTP223.pdf"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-Touch_Sensor/master/res/Touch_sensor_Eagle_File.zip"]}}}},{"Library":"uartat","Description":"Generic AT Command Based UART Device Library","Sensor Class":{"uartat":{"Name":"API for a Generic AT command based UART device","Description":"This is the UPM Module for a Generic AT command based UART device. This is a generic UART device driver for accessing UART based devices that utilize an \"AT\" command set.  Typically these devices are Radios, Modems, and similar devices that are configured and controlled by emitting \"AT\" commands.","Aliases":["uartat"],"Categories":["other"],"Connections":["uart"],"Project Type":["other"],"Manufacturers":["generic"],"Image":"uartat.jpg","Examples":{"Java":["LE910_Example.java"],"Python":["le910.py"],"Node.js":["le910.js"],"C++":["uartat-le910.cxx"],"C":["uartat-le910.c"]},"Urls":{"Product Pages":["https://github.com/intel-iot-devkit/upm/tree/master/src/uartat"]}}}},{"Library":"uln200xa","Description":"ULN200XA Stepper Driver Library","Sensor Class":{"uln200xa":{"Name":"UPM module for the ULN200XA Darlington Stepper Driver","Description":"This is the UPM Module for the ULN200XA Darlington Stepper Driver. This module was developed on a ULN2003A Stepper Driver. It should also support the ULN2001A, ULN2002A, and ULN2004A devices, when using to drive the 28BYJ-48 unipolar stepper motor.","Aliases":["ULN200XA","ULN2001A","ULN2002A","ULN2003A","ULN2004A"],"Categories":["motor"],"Connections":["gpio"],"Project Type":["prototyping","robotics"],"Manufacturers":["Seeed"],"Image":"uln200xa.jpg","Examples":{"Java":["ULN200XASample.java"],"Python":["uln200xa.py"],"Node.js":["uln200xa.js"],"C++":["uln200xa.cxx"],"C":["uln200xa.c"]},"Specifications":{"Vsource":{"unit":"V","min":2.4,"max":13},"Supply Current":{"unit":"uA","min":500,"max":1450},"Operating Temperature":{"unit":"°C","min":-20,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Gear-Stepper-Motor-with-Driver-p-1685.html?cPath=39_40"],"Datasheets":["http://www.seeedstudio.com/document/pdf/Stepper%20Motor%20Datasheet.pdf","http://www.seeedstudio.com/document/pdf/ULN2003%20Datasheet.pdf"],"Schematics":["http://www.seeedstudio.com/document/pdf/Driver%20Board%20Schematic.pdf"]}}}},{"Library":"ultrasonic","Description":"Grove ultrasonic sensor Library","Sensor Class":{"ultrasonic":{"Name":"API for the Grove Ultrasonic Ranger","Description":"This is the UPM Module for the Grove Ultrasonic Ranger. This Grove Ultrasonic sensor is a non-contact distance measurement module which is compatible with the Grove system. It is designed for easy modular project usage with industrial performance. Detection ranges from 3 cm (1.2\") to 4 m (13'1.5\") and works best when the object is within a 30 degree angle relative to the sensor.","Aliases":["ultrasonic","Grove - Ultrasonic Ranger"],"Categories":["sound"],"Connections":["gpio"],"Project Type":["prototyping","robotics","commercial"],"Manufacturers":["Seeed"],"Image":"ultrasonic.jpg","Examples":{"Node.js":["ultrasonic.js"],"C++":["ultrasonic.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.2,"max":5.2},"Supply Current":{"unit":"mA","typ":8},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Ultrasonic Frequency":{"unit":"kHz","typ":40},"Effective Range":{"unit":"cm","min":2,"max":350},"Resolution":{"unit":"cm","min":-1,"max":1}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Ultrasonic-Ranger-p-960.html","http://wiki.seeed.cc/Grove-Ultrasonic_Ranger/"]}}}},{"Library":"urm37","Description":"DFRobot URM37 Ultrasonic Ranger Library","Sensor Class":{"urm37":{"Name":"API for the DFRobot URM37 Ultrasonic Ranger","Description":"This is the UPM Module for the DFRobot URM37 Ultrasonic Ranger. This library was tested with the DFRobot URM37 Ultrasonic Ranger, V4.  It has a range of between 5 and 500 centimeters (cm).  It supports both analog distance measurement, and UART based temperature and distance measurements.  This driver does not support PWM measurement mode. For UART operation, the only supported baud rate is 9600.  In addition, you must ensure that the UART TX/RX pins are configured for TTL operation (the factory default) rather than RS232 operation, or permanent damage to your URM37 and/or MCU will result.  On power up, the LED indicator will blink one long pulse, followed by one short pulse to indicate TTL operation.","Aliases":["urm37","URM37 V4.0 Ultrasonic Sensor"],"Categories":["sound"],"Connections":["uart","ainput","gpio"],"Project Type":["prototyping","robotics","commercial"],"Manufacturers":["DFRobot"],"Image":"urm37.jpg","Examples":{"Python":["urm37-uart.py","urm37.py"],"Node.js":["urm37-uart.js","urm37.js"],"C++":["urm37-uart.cxx","urm37.cxx"],"C":["urm37-uart.c","urm37.c"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5},"Supply Current":{"unit":"mA","typ":"<20"},"Operating Temperature":{"unit":"°C","min":-10,"max":70},"Effective Range":{"unit":"cm","min":5,"max":500},"Resolution":{"unit":"cm","resolution":1}},"Urls":{"Product Pages":["https://www.dfrobot.com/product-53.html","https://www.dfrobot.com/wiki/index.php/URM37_V4.0_Ultrasonic_Sensor_(SKU:SEN0001)"]}}}},{"Library":"vcap","Description":"Take a snapshot from a video camera and save as a JPEG","Sensor Class":{"vcap":{"Name":"API for the Video Capture driver","Description":"This is the UPM Module for the Video Capture driver. This UPM module captures a still frame from a Linux V4L device, such as a USB webcam, and and then allows you to save it as a JPEG image into a file. The camera and driver in use must support streaming, mmap-able buffers and must provide data in YUYV format.  This should encompass most video cameras out there.  It has been tested with a few off the shelf cameras without any problems.","Aliases":["vcap"],"Categories":["video"],"Connections":["other"],"Project Type":["medical","industrial","commercial","prototyping"],"Manufacturers":["other"],"Image":"vcap.jpg","Examples":{"Java":["VCAP_Example.java"],"Python":["vcap.py"],"Node.js":["vcap.js"],"C++":["vcap.cxx"]},"Urls":{"Product Pages":["https://github.com/intel-iot-devkit/upm/tree/master/src/vcap"]}}}},{"Library":"vdiv","Description":"Grove Voltage Divider Sensor Library","Sensor Class":{"vdiv":{"Name":"API for the Grove Voltage Divider Sensor","Description":"This is the UPM Module for the Grove Voltage Divider Sensor. The Grove – Voltage Divider provides an interface for measuring extern voltage, eliminating the need to connect a resistance to input interface. Besides, The voltage gain can select by dial switch.They are easy to use.","Aliases":["vdiv","Grove - Voltage Divider","LMV3xx"],"Categories":["electric"],"Connections":["analog"],"Project Type":["prototyping"],"Manufacturers":["Seeed","Texas Instruments"],"Kits":["robok"],"Image":"vdiv.jpg","Examples":{"Java":["VDivSample.java"],"Python":["vdiv.py"],"Node.js":["vdiv.js"],"C++":["vdiv.cxx"],"C":["vdiv.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.7,"max":5.3},"Supply Current":{"unit":"uA","min":130,"max":410},"Operating Temperature":{"unit":"°C","min":-40,"max":125},"Accuracy":{"unit":"%","typ":"<=1"},"External Voltage Range":{"Gain 3":{"unit":"V","min":0.3,"max":12.9},"Gain 10":{"unit":"V","min":1,"max":43}}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Voltage-Divider-p-1472.html","http://wiki.seeed.cc/Grove-Voltage_Divider/"],"Datasheets":["https://github.com/SeeedDocument/Grove-Voltage_Divider/raw/master/res/LMV358ID_Datasheet.pdf"],"Schematics":["https://github.com/SeeedDocument/Grove-Voltage_Divider/raw/master/res/Grove-Voltage_Divider_Eagle_File.zip"]}}}},{"Library":"veml6070","Description":"Vishay VEML6070 UV Sensor Library","Sensor Class":{"veml6070":{"Name":"API for the Vishay VEML6070 UV Sensor","Description":"This is the UPM Module for the Vishay VEML6070 UV Sensor. VEML6070 is an advanced ultraviolet (UV) light sensor with I2C protocol interface and designed by the CMOS process. It is easily operated via a simple I2C command. The active acknowledge (ACK) feature with threshold windows setting allows the UV sensor to send out a UVI alert message. Under a strong solar UVI condition, the smart ACK signal can be easily implemented by the software programming. VEML6070 incorporates a photodiode, amplifiers, and analog / digital circuits into a single chip. VEML6070's adoption of FiltronTM UV technology provides the best spectral sensitivity to cover UV spectrum sensing. It has an excellent temperature compensation and a robust refresh rate setting that does not use an external RC low pass filter. VEML6070 has linear sensitivity to solar UV light and is easily adjusted by an external resistor.","Aliases":["veml6070"],"Categories":["light"],"Connections":["i2c"],"Project Type":["prototyping","commercial"],"Manufacturers":["Vishay","Adafruit"],"Image":"veml6070.jpg","Examples":{"Java":["VEML6070Sample.java"],"Python":["veml6070.py"],"Node.js":["veml6070.js"],"C++":["veml6070.cxx"],"C":["veml6070.c"]},"Specifications":{"Vsource":{"unit":"V","min":2.7,"max":5.5},"Supply Current":{"unit":"uA","min":100,"max":250},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Maximum UVA Sensativity":{"unit":"mW/cm2","typ":328}},"Platforms":{"Intel Joule Module":{"Notes":[]},"Intel Edison":{"Notes":[]}},"Urls":{"Product Pages":["https://www.adafruit.com/product/2899","https://learn.adafruit.com/adafruit-veml6070-uv-light-sensor-breakout/overview?gclid=Cj0KCQjwn6DMBRC0ARIsAHZtCeOQb5G3DDYxFmW9TmWxzijBIP1Gm_gNAo4PZ00Kwz3CGimYd1dBdu4aAo6IEALw_wcB"],"Datasheets":["https://www.vishay.com/docs/84277/veml6070.pdf"]}}}},{"Library":"water","Description":"Grove Water Sensor Library","Sensor Class":{"water":{"Name":"API for the Grove Water Sensor","Description":"This is the UPM Module for the Grove Water Sensor. This sensor detects the presence of water using exposed PCB traces. The sensor is made up of interlaced traces of Ground and Sensor signals. The sensor traces are weakly pulled up using 1 MΩ resistor. The resistor will pull the sensor trace value high until a drop of water shorts the sensor trace to the ground trace. This circuit will work with digital I/O pins of Arduino or you can use it with the analog pins to detect the amount of water induced contact between the grounded and sensor traces.","Aliases":["water","Grove - Water Sensor"],"Categories":["liquid"],"Connections":["gpio"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Kits":["eak"],"Image":"water.jpg","Examples":{"Java":["WaterSample.java"],"Python":["water.py"],"Node.js":["water.js"],"C++":["water.cxx"],"C":["water.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.75,"max":5.25},"Supply Current":{"unit":"mA","typ":"<20"},"Operating Temperature":{"unit":"°C","min":10,"max":30},"Operating Humidity":{"unit":"%RH","min":10,"max":90}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Water-Sensor-p-748.html?gclid=Cj0KCQjwn6DMBRC0ARIsAHZtCeM6_FaKXMn5-4xpQYuyJgydq_exuH2PqkKAKnKsTha_iJzXneoWL7EaAohrEALw_wcB","http://wiki.seeed.cc/Grove-Water_Sensor/"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-Water_Sensor/master/res/Water_sensor.zip"]}}}},{"Library":"waterlevel","Description":"Grove Water Level Switch Library","Sensor Class":{"waterlevel":{"Name":"API for the Grove Water Level Switch","Description":"This is the UPM Module for the Grove Water Level Switch. This switch is a device used to sense the level of liquid within a tank, it may actuate a pump, an indicator, an alarm, or other devices. When the float ball rises or falls with the liquid to the level of the switch, The magnetic force of magnet which inside of the float ball will cause the reed switch to turn ON. When the float ball move away from the reed switch, the reed switch will turn OFF.","Aliases":["waterlevel","Water level switch"],"Categories":["liquid"],"Connections":["gpio"],"Project Type":["prototyping","commercial"],"Manufacturers":["Seeed"],"Image":"waterlevel.jpg","Examples":{"Java":["WaterLevelSensor.java"],"Python":["waterlevel.py"],"Node.js":["waterlevel.js"],"C++":["waterlevel.cxx"]},"Specifications":{"Switching Voltage":{"unit":"V","min":3.3,"max":100},"Switching Current":{"unit":"A","max":0.5},"Operating Temperature":{"unit":"°C","min":-10,"max":80}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Water-level-switch-p-565.html"]}}}},{"Library":"wfs","Description":"Grove Water Flow Sensor Library","Sensor Class":{"wfs":{"Name":"API for the Grove Water Flow Sensor","Description":"This is the UPM Module for the Grove Water Flow Sensor. This sensor is used to measure water flow in liters per minute (LPM). It incorporates a Hall Effect sensor. The UPM module defines an interrupt routine to be triggered on each low pulse, keeping count. This device requires a 10K pull-up resistor for the signal line (yellow wire). However, be careful when wiring this up - the schematic appears to have a bug in it: the lower left connection of the signal line (yellow) to Vcc (red) should not be there. The sensor can work with this connection, but probably not for very long.","Aliases":["wfs","G1/2 Water Flow sensor"],"Categories":["liquid"],"Connections":["gpio"],"Project Type":["mprototyping","commercial"],"Manufacturers":["Seeed"],"Kits":["eak"],"Image":"wfs.jpg","Examples":{"Java":["WFSSample.java"],"Python":["wfs.py"],"Node.js":["wfs.js"],"C++":["wfs.cxx"],"C":["wfs.c"]},"Specifications":{"Vsource":{"unit":"V","min":5,"max":24},"Supply Current":{"unit":"mA","max":15},"Operating Temperature":{"Air":{"unit":"°C","min":-10,"max":80},"Liquid":{"unit":"°C","min":0,"max":120}},"Operating Humidity":{"unit":"%RH","min":35,"max":90},"Flow Rate":{"unit":"L/min","min":1,"max":30},"Water Pressyre":{"unit":"MPa","max":2}},"Platforms":{"Intel Joule Module":{"Notes":["Might need pull up resistors"]},"Intel Edison":{"Notes":["Might need pull up resistors"]},"Arduino 101":{"Notes":["Might need pull up resistors"]}},"Urls":{"Product Pages":["http://wiki.seeedstudio.com/wiki/G1/2_Water_Flow_sensor"]}}}},{"Library":"wheelencoder","Description":"FRobot Wheel Encoder Library","Sensor Class":{"wheelencoder":{"Name":"API for the DFRobot Wheel Encoder","Description":"This is the UPM Module for the DFRobot Wheel Encoder. This sensor was developed for the DFRobot Wheel Encoder, though it could be used for any counting time-based task.  When you instantiate a class of this type, the gpio pin specified is connected to an interrupt.  Whenever a low to high transition occurs on the gpio pin, the internal counter is incremented by one. This class also includes a millisecond counter, so that you can correlate the number of counts to a time period for calculating an RPM or other value as needed.","Aliases":["wheelencoder","Gravity:TT Motor Encoders Kit"],"Categories":["other"],"Connections":["gpio"],"Project Type":["prototyping","robotics"],"Manufacturers":["DFRobot"],"Image":"wheelencoder.jpg","Examples":{"Python":["wheelencoder.py"],"Node.js":["wheelencoder.js"],"C++":["wheelencoder.cxx"]},"Specifications":{"Vsource":{"unit":"V","max":5},"Supply Current":{"unit":"mA","max":20},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Resolution":{"unit":"PPR","resolution":20}},"Platforms":{"Intel Edison":{"Notes":["Might need the Gravity: IO Expansion Shield"]},"Arduino 101":{"Notes":["Might need the Gravity: IO Expansion Shield"]}},"Urls":{"Product Pages":["https://www.dfrobot.com/product-98.html"],"Datasheets":["https://www.dfrobot.com/wiki/index.php/Wheel_Encoders_for_DFRobot_3PA_and_4WD_Rovers_(SKU:SEN0038)"],"Schematics":["http://www.dfrobot.com/wiki/images/b/b9/FIT0029_Encoder_Schematics.png"]}}}},{"Library":"wt5001","Description":"WT5001 Serial MP3 module Library","Sensor Class":{"wt5001":{"Name":"API for the WT5001 Serial MP3 Module","Description":"This is the UPM Module for the WT5001 Serial MP3 Module. Grove-Serial MP3 Player is a kind of simple MP3 player device whose design is based on a high-quality MP3 audio chip---WT5001. It can support 8KHZ~44.1KHZ sampling frequency MP3 and WAV file formats. This product has several peripheral ports: a standard UART Grove interface, a dual track headphone jack, an external interface and also a  micro SD card interface. You can control the MP3 playback state by sending commands to module via serial port tools, such as switch songs, change the volume and play mode and so on. It seems a simple module, but it owns such strong function. Want to know how the sound quality? Please come to experience it! NOTE: This product is retired, please consider the Grove - MP3 v2.0 as your alternative choice. This UPM module has not been tested with V2.0.","Aliases":["wt5001","Grove - Serial MP3 Player"],"Categories":["sound"],"Connections":["uart"],"Project Type":["prototyping"],"Manufacturers":["Seeed"],"Image":"wt5001.jpg","Examples":{"Java":["WT5001Sample.java"],"Python":["wt5001.py"],"Node.js":["wt5001.js"],"C++":["wt5001.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.3,"max":5.2},"Supply Current":{"unit":"mA","min":37.6,"max":52},"Operating Temperature":{"unit":"°C","min":-40,"max":85}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/grove-serial-mp3-player-p-1542.html","http://wiki.seeedstudio.com/wiki/Grove_%E2%80%93_Serial_MP3_Player"],"Datasheets":["http://wiki.seeedstudio.com/images/2/26/WT5001_datasheet_V1.5.pdf"]}}}},{"Library":"xbee","Description":"XBee modules Library","Sensor Class":{"xbee":{"Name":"API for the XBee modules","Description":"This is the UPM Module for the XBee modules. This is a generic UART driver for use with Digi XBee modules. It was tested with the XBee S1 802.15.4 module and the XBee S6B WiFi module. It provides basic UART support for sending and receiving data to and from the device.  It is controlled by an AT or API command set. It is connected at 9600 baud by default.","Aliases":["xbee","XBee 1mW Trace Antenna - Series 1 (802.15.4)"],"Categories":["wifi"],"Connections":["uart"],"Project Type":["prototyping","commercial"],"Manufacturers":["SparkFun"],"Image":"xbee.jpg","Examples":{"Python":["xbee.py"],"Node.js":["xbee.js"],"C++":["xbee.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":2.8,"max":3.4},"Supply Current":{"XBee":{"unit":"mA","min":45,"max":50},"XBee PRO":{"min":55,"max":215}},"Operating Temperature":{"unit":"°C","min":-40,"max":85},"Band":{"unit":"GHz","frequency":2.4}},"Platforms":{"Intel Edison":{"Notes":["Might need XBee shield"]},"Arduino 101":{"Notes":["Might need XBee shield"]}},"Urls":{"Product Pages":["https://www.sparkfun.com/products/11215"],"Datasheets":["https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Datasheet.pdf"],"Schematics":["https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Dimensional.pdf"]}}}},{"Library":"yg1006","Description":"YG1006 Flame Sensor Library","Sensor Class":{"yg1006":{"Name":"API for the YG1006 Flame Sensor","Description":"This is the UPM Module for the YG1006 Flame Sensor. The Grove - Flame Sensor can be used to detect fire source or other light sources of the wavelength in the range of 760nm - 1100 nm. It is based on the YG1006 sensor which is a high speed and high sensitive NPN silicon phototransistor. Due to its black epoxy, the sensor is sensitive to infrared radiation. In fire fighting robot game, The sensor plays a very important role, it can be used as a robot eyes to find the fire source.","Aliases":["yg1006","Grove - Flame Sensor"],"Categories":["light"],"Connections":["gpio"],"Project Type":["prototyping","industrial","robotics"],"Manufacturers":["Seeed","Texas Instruments"],"Kits":["hak"],"Image":"yg1006.jpg","Examples":{"Java":["YG1006Sample.java"],"Python":["yg1006.py"],"Node.js":["yg1006.js"],"C++":["yg1006.cxx"],"C":["yg1006.c"]},"Specifications":{"Vsource":{"unit":"V","min":4.75,"max":5.3},"Supply Current":{"unit":"mA","typ":20},"Operating Temperature":{"unit":"°C","min":-25,"max":85},"Response Time":{"unit":"us","time":15},"Light Range":{"unit":"nm","min":760,"max":1100},"Effective Range":{"unit":"m","min":0,"max":1}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Flame-Sensor-p-1450.html","http://wiki.seeed.cc/Grove-Flame_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Flame_Sensor/master/res/LM293D.pdf"],"Schematics":["https://raw.githubusercontent.com/SeeedDocument/Grove-Flame_Sensor/master/res/Grove-Directional_Light_Sensor_Eagle_File.zip"]}}}},{"Library":"zfm20","Description":"ZFM-20 Fingerprint Sensor Module","Sensor Class":{"zfm20":{"Name":"API for the ZFM-20 Fingerprint Sensor Module","Description":"This is the UPM Module for the ZFM-20 Fingerprint Sensor Module. The Fingerprint Sensor is one optical fingerprint sensor which will make adding fingerprint detection and verification super simple.There's a high powered DSP chip AS601 that does the image rendering, calculation, feature-finding and searching. You can also enroll new fingers directly - up to 162 finger prints can be stored in the onboard FLASH memory. There's a red LED in the lens that lights up during a photo so you know its working.","Aliases":["zfm20","Grove - Fingerprint Sensor"],"Categories":["touch"],"Connections":["uart"],"Project Type":["medical","prototyping"],"Manufacturers":["Seeed","ZhianTec"],"Image":"zfm20.jpg","Examples":{"Java":["ZFM20Sample.java"],"Python":["zfm20-register.py","zfm20.py"],"Node.js":["zfm20-register.js","zfm20.js"],"C++":["zfm20-register.cxx","zfm20.cxx"]},"Specifications":{"Vsource":{"unit":"V","min":3.6,"max":6},"Supply Current":{"unit":"mA","max":120},"Operating Temperature":{"unit":"°C","min":-20,"max":50},"Imaging Time":{"unit":"s","typ":1},"False Acceptance Rate":{"unit":"%","rate":0.001},"False Reject Rate":{"unit":"%","rate":1},"Baud Rate":{"unit":"bps","default":57600}},"Platforms":{"Intel Edison":{"Notes":["Might need Grove base shield"]},"Arduino 101":{"Notes":["Might need Grove base shield"]}},"Urls":{"Product Pages":["https://www.seeedstudio.com/Grove-Fingerprint-Sensor-p-1424.html","http://wiki.seeed.cc/Grove-Fingerprint_Sensor/"],"Datasheets":["https://raw.githubusercontent.com/SeeedDocument/Grove-Fingerprint_Sensor/master/res/ZFM206%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8CV2.1.pdf","https://github.com/SeeedDocument/Grove-Fingerprint_Sensor/raw/master/res/ZFM-user-manualV15.pdf"]}}}}]